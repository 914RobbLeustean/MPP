{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { throwError, of } from 'rxjs';\nimport { catchError, tap, map, switchMap } from 'rxjs/operators';\nimport { OperationType } from './offline-queue.service';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./network.service\";\nimport * as i3 from \"./indexed-db.service\";\nimport * as i4 from \"./offline-queue.service\";\nimport * as i5 from \"./notification.service\";\nimport * as i6 from \"./auth.service\";\nexport class ListingService {\n  constructor(http, networkService, indexedDBService, offlineQueueService, notificationService, authService) {\n    this.http = http;\n    this.networkService = networkService;\n    this.indexedDBService = indexedDBService;\n    this.offlineQueueService = offlineQueueService;\n    this.notificationService = notificationService;\n    this.authService = authService;\n    this.apiUrl = `${environment.apiUrl}/listings`;\n  }\n  // ✅ FIXED: Update the method signature to return the paginated result\n  getListings(params = {}) {\n    let httpParams = new HttpParams();\n    // ✅ FIXED: Build parameters properly\n    Object.keys(params).forEach(key => {\n      if (params[key] !== null && params[key] !== undefined && params[key] !== '') {\n        httpParams = httpParams.set(key, params[key].toString());\n      }\n    });\n    console.log('🔍 Sending HTTP params:', httpParams.toString()); // Debug log\n    // Check if online\n    if (this.networkService.isOnline) {\n      return this.http.get(this.apiUrl, {\n        params: httpParams\n      }).pipe(tap(response => {\n        console.log('📥 API Response:', response); // Debug log\n        // Cache the listings\n        if (response.items) {\n          response.items.forEach(listing => {\n            this.indexedDBService.put('listings', listing).subscribe();\n          });\n        }\n      }), catchError(error => {\n        console.error('❌ API Error:', error); // Debug log\n        this.notificationService.show('Error loading listings from server. Using offline data.', 'error');\n        return this.getOfflineListings(params);\n      }));\n    } else {\n      // If offline, use cached data\n      return this.getOfflineListings(params);\n    }\n  }\n  getOfflineListings(params) {\n    return this.indexedDBService.getAll('listings').pipe(map(listings => {\n      // Apply basic filters if params are present\n      let filteredListings = listings;\n      // Quality filter\n      if (params.quality) {\n        filteredListings = filteredListings.filter(l => l.quality === params.quality);\n      }\n      // Search filter\n      if (params.search) {\n        const searchLower = params.search.toLowerCase();\n        filteredListings = filteredListings.filter(l => l.title.toLowerCase().includes(searchLower) || l.description && l.description.toLowerCase().includes(searchLower));\n      }\n      // ✅ FIXED: Price range filters\n      if (params.minPrice && params.minPrice > 0) {\n        filteredListings = filteredListings.filter(l => l.price >= parseFloat(params.minPrice));\n      }\n      if (params.maxPrice && params.maxPrice < 10000) {\n        filteredListings = filteredListings.filter(l => l.price <= parseFloat(params.maxPrice));\n      }\n      // ✅ FIXED: Sorting\n      if (params.sortBy) {\n        switch (params.sortBy) {\n          case 'price_asc':\n            filteredListings = filteredListings.sort((a, b) => a.price - b.price);\n            break;\n          case 'price_desc':\n            filteredListings = filteredListings.sort((a, b) => b.price - a.price);\n            break;\n          case 'oldest':\n            filteredListings = filteredListings.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n            break;\n          default:\n            // newest\n            filteredListings = filteredListings.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n            break;\n        }\n      } else {\n        // Default sort by newest\n        filteredListings = filteredListings.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n      }\n      // Get total count before pagination\n      const totalCount = filteredListings.length;\n      // Handle pagination if provided\n      if (params.page && params.pageSize) {\n        const startIndex = (params.page - 1) * params.pageSize;\n        filteredListings = filteredListings.slice(startIndex, startIndex + params.pageSize);\n      }\n      return {\n        items: filteredListings,\n        totalCount: totalCount\n      };\n    }), catchError(error => {\n      this.notificationService.show('Error loading offline listings', 'error');\n      return of({\n        items: [],\n        totalCount: 0\n      });\n    }));\n  }\n  getNewListings(count = 8) {\n    if (this.networkService.isOnline) {\n      return this.http.get(`${this.apiUrl}/new`, {\n        params: new HttpParams().set('count', count.toString())\n      }).pipe(tap(listings => {\n        // Cache the listings\n        listings.forEach(listing => {\n          this.indexedDBService.put('listings', listing).subscribe();\n        });\n      }), catchError(error => {\n        this.notificationService.show('Error loading new listings from server. Using offline data.', 'error');\n        return this.getOfflineNewListings(count);\n      }));\n    } else {\n      return this.getOfflineNewListings(count);\n    }\n  }\n  getOfflineNewListings(count) {\n    return this.indexedDBService.getAll('listings').pipe(map(listings => {\n      // Sort by creation date (newest first) and take the specified count\n      return listings.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()).slice(0, count);\n    }));\n  }\n  getListingById(id) {\n    if (this.networkService.isOnline) {\n      return this.http.get(`${this.apiUrl}/${id}`).pipe(tap(listing => {\n        this.indexedDBService.put('listings', listing).subscribe();\n      }), catchError(error => {\n        return this.getOfflineListing(id);\n      }));\n    } else {\n      return this.getOfflineListing(id);\n    }\n  }\n  getOfflineListing(id) {\n    return this.indexedDBService.get('listings', id).pipe(switchMap(listing => {\n      if (listing) {\n        return of(listing);\n      } else {\n        this.notificationService.show('Listing not found in offline storage', 'error');\n        return throwError(() => new Error('Listing not found in offline storage'));\n      }\n    }));\n  }\n  getUserListings(userId) {\n    if (this.networkService.isOnline) {\n      return this.http.get(`${this.apiUrl}/user/${userId}`).pipe(tap(listings => {\n        // Cache the listings\n        listings.forEach(listing => {\n          this.indexedDBService.put('listings', listing).subscribe();\n        });\n      }), switchMap(onlineListings => {\n        // Get offline listings as well and combine\n        return this.getOfflineUserListings(userId).pipe(map(offlineListings => {\n          // Filter out any offline listings that were already synced and exist in onlineListings\n          const filteredOfflineListings = offlineListings.filter(offline =>\n          // Only include if no online listing with matching ID exists\n          // (offline listings have negative IDs so there shouldn't be conflicts)\n          !onlineListings.some(online => online.id === offline.id));\n          // Combine online and offline listings\n          return [...onlineListings, ...filteredOfflineListings];\n        }));\n      }), catchError(error => {\n        this.notificationService.show('Error loading user listings from server. Using offline data.', 'error');\n        return this.getOfflineUserListings(userId);\n      }));\n    } else {\n      return this.getOfflineUserListings(userId);\n    }\n  }\n  getOfflineUserListings(userId) {\n    return this.indexedDBService.getAll('listings').pipe(map(listings => {\n      // Filter to only include listings from this user (including temporary IDs) \n      // and not soft-deleted ones\n      return listings.filter(listing => listing.userId === userId && !listing.isDeleted);\n    }));\n  }\n  createListing(formData) {\n    if (this.networkService.isOnline) {\n      return this.http.post(this.apiUrl, formData).pipe(tap(listing => {\n        // Cache the new listing\n        this.indexedDBService.put('listings', listing).subscribe();\n      }), catchError(error => {\n        this.notificationService.show('Error creating listing on server. Queuing for offline sync.', 'error');\n        return this.createOfflineListing(formData);\n      }));\n    } else {\n      return this.createOfflineListing(formData);\n    }\n  }\n  createOfflineListing(formData) {\n    // Extract data from FormData\n    const tempId = -Math.floor(Math.random() * 1000000); // Negative ID to indicate it's temporary\n    // Convert FormData to a regular object\n    const listingData = {};\n    formData.forEach((value, key) => {\n      // Skip file objects for now in the temporary listing object\n      if (!(value instanceof File)) {\n        listingData[key] = value;\n      }\n    });\n    // Get current user info\n    const currentUser = this.authService.getCurrentUser();\n    if (!currentUser) {\n      return throwError(() => new Error('User must be logged in to create listings'));\n    }\n    // Create a temporary listing object\n    const tempListing = {\n      id: tempId,\n      title: listingData.title || 'Untitled',\n      measurement: listingData.measurement || '',\n      quality: listingData.quality || '',\n      price: parseFloat(listingData.price) || 0,\n      description: listingData.description || '',\n      createdAt: new Date(),\n      userId: currentUser.id,\n      userName: currentUser.username || `${currentUser.firstName} ${currentUser.lastName}`,\n      photoUrls: [],\n      isOfflinePending: true\n    };\n    // Store in IndexedDB\n    return this.indexedDBService.put('listings', tempListing).pipe(switchMap(savedListing => {\n      // Queue operation for later sync\n      return this.offlineQueueService.queueOperation({\n        entityType: 'listing',\n        operationType: OperationType.CREATE,\n        payload: this.formDataToObject(formData),\n        timestamp: Date.now(),\n        tempId: tempId\n      }).pipe(map(() => {\n        this.notificationService.show('Listing saved offline and will sync when online', 'info');\n        return savedListing;\n      }));\n    }));\n  }\n  updateListing(id, formData) {\n    if (this.networkService.isOnline) {\n      return this.http.put(`${this.apiUrl}/${id}`, formData).pipe(tap(listing => {\n        // Update the cache\n        this.indexedDBService.put('listings', listing).subscribe();\n      }), catchError(error => {\n        this.notificationService.show('Error updating listing on server. Queuing for offline sync.', 'error');\n        return this.updateOfflineListing(id, formData);\n      }));\n    } else {\n      return this.updateOfflineListing(id, formData);\n    }\n  }\n  updateOfflineListing(id, formData) {\n    // First get the existing listing\n    return this.indexedDBService.get('listings', id).pipe(switchMap(existingListing => {\n      if (!existingListing) {\n        return throwError(() => new Error('Listing not found in offline storage'));\n      }\n      // Convert FormData to a regular object\n      const updateData = {};\n      formData.forEach((value, key) => {\n        // Skip file objects for now in the temporary update object\n        if (!(value instanceof File)) {\n          updateData[key] = value;\n        }\n      });\n      // Update the listing with new values\n      const updatedListing = {\n        ...existingListing,\n        title: updateData.title || existingListing.title,\n        measurement: updateData.measurement || existingListing.measurement,\n        quality: updateData.quality || existingListing.quality,\n        price: parseFloat(updateData.price) || existingListing.price,\n        description: updateData.description || existingListing.description,\n        isOfflinePending: true\n      };\n      // Store the updated listing\n      return this.indexedDBService.put('listings', updatedListing).pipe(switchMap(savedListing => {\n        // Queue the operation for later sync\n        return this.offlineQueueService.queueOperation({\n          entityType: 'listing',\n          entityId: id,\n          operationType: OperationType.UPDATE,\n          payload: this.formDataToObject(formData),\n          timestamp: Date.now()\n        }).pipe(map(() => {\n          this.notificationService.show('Listing updated offline and will sync when online', 'info');\n          return savedListing;\n        }));\n      }));\n    }));\n  }\n  deleteListing(id) {\n    if (this.networkService.isOnline) {\n      return this.http.delete(`${this.apiUrl}/${id}`).pipe(tap(() => {\n        // Remove from cache\n        this.indexedDBService.delete('listings', id).subscribe();\n      }), catchError(error => {\n        this.notificationService.show('Error deleting listing from server. Queuing for offline sync.', 'error');\n        return this.deleteOfflineListing(id);\n      }));\n    } else {\n      return this.deleteOfflineListing(id);\n    }\n  }\n  deleteOfflineListing(id) {\n    return this.indexedDBService.get('listings', id).pipe(switchMap(listing => {\n      if (!listing) {\n        return throwError(() => new Error('Listing not found in offline storage'));\n      }\n      // If this is a temporary ID (negative), it was created offline\n      if (id < 0) {\n        // Find and remove any pending create operations for this listing\n        return this.offlineQueueService.getPendingOperations().pipe(switchMap(operations => {\n          const createOp = operations.find(op => op.operationType === OperationType.CREATE && op.entityType === 'listing' && op.tempId === id);\n          if (createOp && createOp.id) {\n            // Remove the create operation from the queue\n            return this.offlineQueueService.removePendingOperation(createOp.id).pipe(switchMap(() => this.indexedDBService.delete('listings', id)), map(() => true));\n          } else {\n            // Just remove from IndexedDB\n            return this.indexedDBService.delete('listings', id).pipe(map(() => true));\n          }\n        }));\n      } else {\n        // This is a server-side listing - mark as deleted locally\n        listing.isDeleted = true;\n        listing.isOfflinePending = true;\n        return this.indexedDBService.put('listings', listing).pipe(switchMap(() => {\n          // Queue the delete operation\n          return this.offlineQueueService.queueOperation({\n            entityType: 'listing',\n            entityId: id,\n            operationType: OperationType.DELETE,\n            payload: null,\n            timestamp: Date.now()\n          });\n        }), map(() => {\n          this.notificationService.show('Listing marked for deletion and will be removed when online', 'info');\n          return true;\n        }));\n      }\n    }));\n  }\n  searchListings(query, priceRange) {\n    if (this.networkService.isOnline) {\n      let params = new HttpParams().set('q', query);\n      // ✅ FIXED: Add price range parameters if provided\n      if (priceRange) {\n        if (priceRange.min > 0) {\n          params = params.set('minPrice', priceRange.min.toString());\n        }\n        if (priceRange.max > 0 && priceRange.max < 10000) {\n          params = params.set('maxPrice', priceRange.max.toString());\n        }\n      }\n      console.log('🔍 Search params:', params.toString()); // Debug log\n      return this.http.get(`${this.apiUrl}/search`, {\n        params\n      }).pipe(tap(listings => {\n        console.log('📥 Search results:', listings); // Debug log\n        // Cache the search results\n        listings.forEach(listing => {\n          this.indexedDBService.put('listings', listing).subscribe();\n        });\n      }), catchError(error => {\n        console.error('❌ Search error:', error); // Debug log\n        this.notificationService.show('Error searching listings. Using offline search.', 'error');\n        return this.searchOfflineListings(query, priceRange);\n      }));\n    } else {\n      return this.searchOfflineListings(query, priceRange);\n    }\n  }\n  searchOfflineListings(query, priceRange) {\n    return this.indexedDBService.getAll('listings').pipe(map(listings => {\n      const searchLower = query.toLowerCase();\n      let filteredListings = listings.filter(listing => listing.title.toLowerCase().includes(searchLower) || listing.description && listing.description.toLowerCase().includes(searchLower) || listing.measurement.toLowerCase().includes(searchLower) || listing.quality.toLowerCase().includes(searchLower));\n      // ✅ FIXED: Apply price range filter\n      if (priceRange) {\n        filteredListings = filteredListings.filter(listing => listing.price >= priceRange.min && listing.price <= priceRange.max);\n      }\n      return filteredListings;\n    }));\n  }\n  // Helper method to convert FormData to object for offline queue\n  formDataToObject(formData) {\n    const obj = {};\n    formData.forEach((value, key) => {\n      if (value instanceof File) {\n        // For files, you might want to store metadata only\n        // In a full implementation, you'd handle file storage separately\n        if (!obj.files) obj.files = [];\n        obj.files.push({\n          name: value.name,\n          type: value.type,\n          size: value.size\n        });\n      } else {\n        obj[key] = value;\n      }\n    });\n    return obj;\n  }\n  // Error handling method\n  handleError(error) {\n    console.error('API Error Response:', error);\n    let errorMessage = 'Unknown error occurred';\n    // Try to extract more detailed error information\n    if (error.error instanceof ErrorEvent) {\n      // Client-side error\n      errorMessage = `Error: ${error.error.message}`;\n    } else {\n      // Server-side error\n      errorMessage = `Error Code: ${error.status}\\nMessage: ${error.message}`;\n      // Try to extract more detailed error from response body\n      if (error.error) {\n        if (typeof error.error === 'string') {\n          errorMessage += `\\nDetails: ${error.error}`;\n        } else if (error.error.errors) {\n          // This extracts validation errors from ASP.NET Core response\n          errorMessage += '\\nValidation Errors:';\n          for (const key in error.error.errors) {\n            if (error.error.errors.hasOwnProperty(key)) {\n              errorMessage += `\\n- ${key}: ${error.error.errors[key].join(', ')}`;\n            }\n          }\n        }\n      }\n    }\n    console.error(errorMessage);\n    return throwError(() => new Error(errorMessage));\n  }\n  static {\n    this.ɵfac = function ListingService_Factory(t) {\n      return new (t || ListingService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.NetworkService), i0.ɵɵinject(i3.IndexedDBService), i0.ɵɵinject(i4.OfflineQueueService), i0.ɵɵinject(i5.NotificationService), i0.ɵɵinject(i6.AuthService));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ListingService,\n      factory: ListingService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["HttpParams","throwError","of","catchError","tap","map","switchMap","OperationType","environment","ListingService","constructor","http","networkService","indexedDBService","offlineQueueService","notificationService","authService","apiUrl","getListings","params","httpParams","Object","keys","forEach","key","undefined","set","toString","console","log","isOnline","get","pipe","response","items","listing","put","subscribe","error","show","getOfflineListings","getAll","listings","filteredListings","quality","filter","l","search","searchLower","toLowerCase","title","includes","description","minPrice","price","parseFloat","maxPrice","sortBy","sort","a","b","Date","createdAt","getTime","totalCount","length","page","pageSize","startIndex","slice","getNewListings","count","getOfflineNewListings","getListingById","id","getOfflineListing","Error","getUserListings","userId","onlineListings","getOfflineUserListings","offlineListings","filteredOfflineListings","offline","some","online","isDeleted","createListing","formData","post","createOfflineListing","tempId","Math","floor","random","listingData","value","File","currentUser","getCurrentUser","tempListing","measurement","userName","username","firstName","lastName","photoUrls","isOfflinePending","savedListing","queueOperation","entityType","operationType","CREATE","payload","formDataToObject","timestamp","now","updateListing","updateOfflineListing","existingListing","updateData","updatedListing","entityId","UPDATE","deleteListing","delete","deleteOfflineListing","getPendingOperations","operations","createOp","find","op","removePendingOperation","DELETE","searchListings","query","priceRange","min","max","searchOfflineListings","obj","files","push","name","type","size","handleError","errorMessage","ErrorEvent","message","status","errors","hasOwnProperty","join","i0","ɵɵinject","i1","HttpClient","i2","NetworkService","i3","IndexedDBService","i4","OfflineQueueService","i5","NotificationService","i6","AuthService","factory","ɵfac","providedIn"],"sources":["C:\\Users\\leust\\source\\repos\\MPP-main\\Thrifto\\thrifto.client\\src\\app\\services\\listing.service.ts"],"sourcesContent":["// src/app/services/listing.service.ts\r\nimport { Injectable } from '@angular/core';\r\nimport { HttpClient, HttpParams, HttpErrorResponse } from '@angular/common/http';\r\nimport { Observable, throwError, of } from 'rxjs';\r\nimport { catchError, tap, map, switchMap } from 'rxjs/operators';\r\nimport { Listing } from '../models/listing.model';\r\nimport { NetworkService, ConnectionStatus } from './network.service';\r\nimport { IndexedDBService } from './indexed-db.service';\r\nimport { OfflineQueueService, OperationType } from './offline-queue.service';\r\nimport { NotificationService } from './notification.service';\r\nimport { AuthService } from './auth.service';\r\nimport { PriceRange } from '../components/shared/price-range-filter/price-range-filter.component';\r\nimport { environment } from '../../environments/environment';\r\n\r\n@Injectable({\r\n    providedIn: 'root'\r\n})\r\nexport class ListingService {\r\n    private apiUrl = `${environment.apiUrl}/listings`;\r\n\r\n    constructor(\r\n        private http: HttpClient,\r\n        private networkService: NetworkService,\r\n        private indexedDBService: IndexedDBService,\r\n        private offlineQueueService: OfflineQueueService,\r\n        private notificationService: NotificationService,\r\n        private authService: AuthService\r\n    ) { }\r\n\r\n    // ✅ FIXED: Update the method signature to return the paginated result\r\n    getListings(params: any = {}): Observable<{ items: Listing[], totalCount: number }> {\r\n        let httpParams = new HttpParams();\r\n\r\n        // ✅ FIXED: Build parameters properly\r\n        Object.keys(params).forEach(key => {\r\n            if (params[key] !== null && params[key] !== undefined && params[key] !== '') {\r\n                httpParams = httpParams.set(key, params[key].toString());\r\n            }\r\n        });\r\n\r\n        console.log('🔍 Sending HTTP params:', httpParams.toString()); // Debug log\r\n\r\n        // Check if online\r\n        if (this.networkService.isOnline) {\r\n            return this.http.get<{ items: Listing[], totalCount: number }>(this.apiUrl, { params: httpParams }).pipe(\r\n                tap(response => {\r\n                    console.log('📥 API Response:', response); // Debug log\r\n                    // Cache the listings\r\n                    if (response.items) {\r\n                        response.items.forEach(listing => {\r\n                            this.indexedDBService.put('listings', listing).subscribe();\r\n                        });\r\n                    }\r\n                }),\r\n                catchError(error => {\r\n                    console.error('❌ API Error:', error); // Debug log\r\n                    this.notificationService.show('Error loading listings from server. Using offline data.', 'error');\r\n                    return this.getOfflineListings(params);\r\n                })\r\n            );\r\n        } else {\r\n            // If offline, use cached data\r\n            return this.getOfflineListings(params);\r\n        }\r\n    }\r\n\r\n    private getOfflineListings(params: any): Observable<{ items: Listing[], totalCount: number }> {\r\n        return this.indexedDBService.getAll<Listing>('listings').pipe(\r\n            map(listings => {\r\n                // Apply basic filters if params are present\r\n                let filteredListings = listings;\r\n\r\n                // Quality filter\r\n                if (params.quality) {\r\n                    filteredListings = filteredListings.filter(l => l.quality === params.quality);\r\n                }\r\n\r\n                // Search filter\r\n                if (params.search) {\r\n                    const searchLower = params.search.toLowerCase();\r\n                    filteredListings = filteredListings.filter(l =>\r\n                        l.title.toLowerCase().includes(searchLower) ||\r\n                        (l.description && l.description.toLowerCase().includes(searchLower))\r\n                    );\r\n                }\r\n\r\n                // ✅ FIXED: Price range filters\r\n                if (params.minPrice && params.minPrice > 0) {\r\n                    filteredListings = filteredListings.filter(l => l.price >= parseFloat(params.minPrice));\r\n                }\r\n\r\n                if (params.maxPrice && params.maxPrice < 10000) {\r\n                    filteredListings = filteredListings.filter(l => l.price <= parseFloat(params.maxPrice));\r\n                }\r\n\r\n                // ✅ FIXED: Sorting\r\n                if (params.sortBy) {\r\n                    switch (params.sortBy) {\r\n                        case 'price_asc':\r\n                            filteredListings = filteredListings.sort((a, b) => a.price - b.price);\r\n                            break;\r\n                        case 'price_desc':\r\n                            filteredListings = filteredListings.sort((a, b) => b.price - a.price);\r\n                            break;\r\n                        case 'oldest':\r\n                            filteredListings = filteredListings.sort((a, b) =>\r\n                                new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\r\n                            break;\r\n                        default: // newest\r\n                            filteredListings = filteredListings.sort((a, b) =>\r\n                                new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\r\n                            break;\r\n                    }\r\n                } else {\r\n                    // Default sort by newest\r\n                    filteredListings = filteredListings.sort((a, b) =>\r\n                        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\r\n                    );\r\n                }\r\n\r\n                // Get total count before pagination\r\n                const totalCount = filteredListings.length;\r\n\r\n                // Handle pagination if provided\r\n                if (params.page && params.pageSize) {\r\n                    const startIndex = (params.page - 1) * params.pageSize;\r\n                    filteredListings = filteredListings.slice(startIndex, startIndex + params.pageSize);\r\n                }\r\n\r\n                return {\r\n                    items: filteredListings,\r\n                    totalCount: totalCount\r\n                };\r\n            }),\r\n            catchError(error => {\r\n                this.notificationService.show('Error loading offline listings', 'error');\r\n                return of({ items: [], totalCount: 0 });\r\n            })\r\n        );\r\n    }\r\n\r\n    getNewListings(count: number = 8): Observable<Listing[]> {\r\n        if (this.networkService.isOnline) {\r\n            return this.http.get<Listing[]>(`${this.apiUrl}/new`, {\r\n                params: new HttpParams().set('count', count.toString())\r\n            }).pipe(\r\n                tap(listings => {\r\n                    // Cache the listings\r\n                    listings.forEach(listing => {\r\n                        this.indexedDBService.put('listings', listing).subscribe();\r\n                    });\r\n                }),\r\n                catchError(error => {\r\n                    this.notificationService.show('Error loading new listings from server. Using offline data.', 'error');\r\n                    return this.getOfflineNewListings(count);\r\n                })\r\n            );\r\n        } else {\r\n            return this.getOfflineNewListings(count);\r\n        }\r\n    }\r\n\r\n    private getOfflineNewListings(count: number): Observable<Listing[]> {\r\n        return this.indexedDBService.getAll<Listing>('listings').pipe(\r\n            map(listings => {\r\n                // Sort by creation date (newest first) and take the specified count\r\n                return listings\r\n                    .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())\r\n                    .slice(0, count);\r\n            })\r\n        );\r\n    }\r\n\r\n    getListingById(id: number): Observable<Listing> {\r\n        if (this.networkService.isOnline) {\r\n            return this.http.get<Listing>(`${this.apiUrl}/${id}`).pipe(\r\n                tap(listing => {\r\n                    this.indexedDBService.put('listings', listing).subscribe();\r\n                }),\r\n                catchError(error => {\r\n                    return this.getOfflineListing(id);\r\n                })\r\n            );\r\n        } else {\r\n            return this.getOfflineListing(id);\r\n        }\r\n    }\r\n\r\n    private getOfflineListing(id: number): Observable<Listing> {\r\n        return this.indexedDBService.get<Listing>('listings', id).pipe(\r\n            switchMap(listing => {\r\n                if (listing) {\r\n                    return of(listing);\r\n                } else {\r\n                    this.notificationService.show('Listing not found in offline storage', 'error');\r\n                    return throwError(() => new Error('Listing not found in offline storage'));\r\n                }\r\n            })\r\n        );\r\n    }\r\n\r\n    getUserListings(userId: string): Observable<Listing[]> {\r\n        if (this.networkService.isOnline) {\r\n            return this.http.get<Listing[]>(`${this.apiUrl}/user/${userId}`).pipe(\r\n                tap(listings => {\r\n                    // Cache the listings\r\n                    listings.forEach(listing => {\r\n                        this.indexedDBService.put('listings', listing).subscribe();\r\n                    });\r\n                }),\r\n                switchMap(onlineListings => {\r\n                    // Get offline listings as well and combine\r\n                    return this.getOfflineUserListings(userId).pipe(\r\n                        map(offlineListings => {\r\n                            // Filter out any offline listings that were already synced and exist in onlineListings\r\n                            const filteredOfflineListings = offlineListings.filter(offline =>\r\n                                // Only include if no online listing with matching ID exists\r\n                                // (offline listings have negative IDs so there shouldn't be conflicts)\r\n                                !onlineListings.some(online => online.id === offline.id)\r\n                            );\r\n                            // Combine online and offline listings\r\n                            return [...onlineListings, ...filteredOfflineListings];\r\n                        })\r\n                    );\r\n                }),\r\n                catchError(error => {\r\n                    this.notificationService.show('Error loading user listings from server. Using offline data.', 'error');\r\n                    return this.getOfflineUserListings(userId);\r\n                })\r\n            );\r\n        } else {\r\n            return this.getOfflineUserListings(userId);\r\n        }\r\n    }\r\n\r\n    private getOfflineUserListings(userId: string): Observable<Listing[]> {\r\n        return this.indexedDBService.getAll<Listing>('listings').pipe(\r\n            map(listings => {\r\n                // Filter to only include listings from this user (including temporary IDs) \r\n                // and not soft-deleted ones\r\n                return listings.filter(listing =>\r\n                    listing.userId === userId &&\r\n                    !listing.isDeleted\r\n                );\r\n            })\r\n        );\r\n    }\r\n\r\n    createListing(formData: FormData): Observable<Listing> {\r\n        if (this.networkService.isOnline) {\r\n            return this.http.post<Listing>(this.apiUrl, formData).pipe(\r\n                tap(listing => {\r\n                    // Cache the new listing\r\n                    this.indexedDBService.put('listings', listing).subscribe();\r\n                }),\r\n                catchError(error => {\r\n                    this.notificationService.show('Error creating listing on server. Queuing for offline sync.', 'error');\r\n                    return this.createOfflineListing(formData);\r\n                })\r\n            );\r\n        } else {\r\n            return this.createOfflineListing(formData);\r\n        }\r\n    }\r\n\r\n    private createOfflineListing(formData: FormData): Observable<Listing> {\r\n        // Extract data from FormData\r\n        const tempId = -Math.floor(Math.random() * 1000000); // Negative ID to indicate it's temporary\r\n\r\n        // Convert FormData to a regular object\r\n        const listingData: any = {};\r\n        formData.forEach((value, key) => {\r\n            // Skip file objects for now in the temporary listing object\r\n            if (!(value instanceof File)) {\r\n                listingData[key] = value;\r\n            }\r\n        });\r\n\r\n        // Get current user info\r\n        const currentUser = this.authService.getCurrentUser();\r\n        if (!currentUser) {\r\n            return throwError(() => new Error('User must be logged in to create listings'));\r\n        }\r\n\r\n        // Create a temporary listing object\r\n        const tempListing: Listing = {\r\n            id: tempId,\r\n            title: listingData.title || 'Untitled',\r\n            measurement: listingData.measurement || '',\r\n            quality: listingData.quality || '',\r\n            price: parseFloat(listingData.price) || 0,\r\n            description: listingData.description || '',\r\n            createdAt: new Date(),\r\n            userId: currentUser.id,\r\n            userName: currentUser.username || `${currentUser.firstName} ${currentUser.lastName}`,\r\n            photoUrls: [],\r\n            isOfflinePending: true\r\n        };\r\n\r\n        // Store in IndexedDB\r\n        return this.indexedDBService.put<Listing>('listings', tempListing).pipe(\r\n            switchMap(savedListing => {\r\n                // Queue operation for later sync\r\n                return this.offlineQueueService.queueOperation({\r\n                    entityType: 'listing',\r\n                    operationType: OperationType.CREATE,\r\n                    payload: this.formDataToObject(formData),\r\n                    timestamp: Date.now(),\r\n                    tempId: tempId\r\n                }).pipe(\r\n                    map(() => {\r\n                        this.notificationService.show('Listing saved offline and will sync when online', 'info');\r\n                        return savedListing;\r\n                    })\r\n                );\r\n            })\r\n        );\r\n    }\r\n\r\n    updateListing(id: number, formData: FormData): Observable<Listing> {\r\n        if (this.networkService.isOnline) {\r\n            return this.http.put<Listing>(`${this.apiUrl}/${id}`, formData).pipe(\r\n                tap(listing => {\r\n                    // Update the cache\r\n                    this.indexedDBService.put('listings', listing).subscribe();\r\n                }),\r\n                catchError(error => {\r\n                    this.notificationService.show('Error updating listing on server. Queuing for offline sync.', 'error');\r\n                    return this.updateOfflineListing(id, formData);\r\n                })\r\n            );\r\n        } else {\r\n            return this.updateOfflineListing(id, formData);\r\n        }\r\n    }\r\n\r\n    private updateOfflineListing(id: number, formData: FormData): Observable<Listing> {\r\n        // First get the existing listing\r\n        return this.indexedDBService.get<Listing>('listings', id).pipe(\r\n            switchMap(existingListing => {\r\n                if (!existingListing) {\r\n                    return throwError(() => new Error('Listing not found in offline storage'));\r\n                }\r\n\r\n                // Convert FormData to a regular object\r\n                const updateData: any = {};\r\n                formData.forEach((value, key) => {\r\n                    // Skip file objects for now in the temporary update object\r\n                    if (!(value instanceof File)) {\r\n                        updateData[key] = value;\r\n                    }\r\n                });\r\n\r\n                // Update the listing with new values\r\n                const updatedListing: Listing = {\r\n                    ...existingListing,\r\n                    title: updateData.title || existingListing.title,\r\n                    measurement: updateData.measurement || existingListing.measurement,\r\n                    quality: updateData.quality || existingListing.quality,\r\n                    price: parseFloat(updateData.price) || existingListing.price,\r\n                    description: updateData.description || existingListing.description,\r\n                    isOfflinePending: true\r\n                };\r\n\r\n                // Store the updated listing\r\n                return this.indexedDBService.put<Listing>('listings', updatedListing).pipe(\r\n                    switchMap(savedListing => {\r\n                        // Queue the operation for later sync\r\n                        return this.offlineQueueService.queueOperation({\r\n                            entityType: 'listing',\r\n                            entityId: id,\r\n                            operationType: OperationType.UPDATE,\r\n                            payload: this.formDataToObject(formData),\r\n                            timestamp: Date.now()\r\n                        }).pipe(\r\n                            map(() => {\r\n                                this.notificationService.show('Listing updated offline and will sync when online', 'info');\r\n                                return savedListing;\r\n                            })\r\n                        );\r\n                    })\r\n                );\r\n            })\r\n        );\r\n    }\r\n\r\n    deleteListing(id: number): Observable<any> {\r\n        if (this.networkService.isOnline) {\r\n            return this.http.delete(`${this.apiUrl}/${id}`).pipe(\r\n                tap(() => {\r\n                    // Remove from cache\r\n                    this.indexedDBService.delete('listings', id).subscribe();\r\n                }),\r\n                catchError(error => {\r\n                    this.notificationService.show('Error deleting listing from server. Queuing for offline sync.', 'error');\r\n                    return this.deleteOfflineListing(id);\r\n                })\r\n            );\r\n        } else {\r\n            return this.deleteOfflineListing(id);\r\n        }\r\n    }\r\n\r\n    private deleteOfflineListing(id: number): Observable<boolean> {\r\n        return this.indexedDBService.get<Listing>('listings', id).pipe(\r\n            switchMap(listing => {\r\n                if (!listing) {\r\n                    return throwError(() => new Error('Listing not found in offline storage'));\r\n                }\r\n\r\n                // If this is a temporary ID (negative), it was created offline\r\n                if (id < 0) {\r\n                    // Find and remove any pending create operations for this listing\r\n                    return this.offlineQueueService.getPendingOperations().pipe(\r\n                        switchMap(operations => {\r\n                            const createOp = operations.find(op =>\r\n                                op.operationType === OperationType.CREATE &&\r\n                                op.entityType === 'listing' &&\r\n                                op.tempId === id\r\n                            );\r\n\r\n                            if (createOp && createOp.id) {\r\n                                // Remove the create operation from the queue\r\n                                return this.offlineQueueService.removePendingOperation(createOp.id).pipe(\r\n                                    switchMap(() => this.indexedDBService.delete('listings', id)),\r\n                                    map(() => true)\r\n                                );\r\n                            } else {\r\n                                // Just remove from IndexedDB\r\n                                return this.indexedDBService.delete('listings', id).pipe(\r\n                                    map(() => true)\r\n                                );\r\n                            }\r\n                        })\r\n                    );\r\n                } else {\r\n                    // This is a server-side listing - mark as deleted locally\r\n                    listing.isDeleted = true;\r\n                    listing.isOfflinePending = true;\r\n\r\n                    return this.indexedDBService.put('listings', listing).pipe(\r\n                        switchMap(() => {\r\n                            // Queue the delete operation\r\n                            return this.offlineQueueService.queueOperation({\r\n                                entityType: 'listing',\r\n                                entityId: id,\r\n                                operationType: OperationType.DELETE,\r\n                                payload: null,\r\n                                timestamp: Date.now()\r\n                            });\r\n                        }),\r\n                        map(() => {\r\n                            this.notificationService.show('Listing marked for deletion and will be removed when online', 'info');\r\n                            return true;\r\n                        })\r\n                    );\r\n                }\r\n            })\r\n        );\r\n    }\r\n\r\n    searchListings(query: string, priceRange?: PriceRange): Observable<Listing[]> {\r\n        if (this.networkService.isOnline) {\r\n            let params = new HttpParams().set('q', query);\r\n\r\n            // ✅ FIXED: Add price range parameters if provided\r\n            if (priceRange) {\r\n                if (priceRange.min > 0) {\r\n                    params = params.set('minPrice', priceRange.min.toString());\r\n                }\r\n                if (priceRange.max > 0 && priceRange.max < 10000) {\r\n                    params = params.set('maxPrice', priceRange.max.toString());\r\n                }\r\n            }\r\n\r\n            console.log('🔍 Search params:', params.toString()); // Debug log\r\n\r\n            return this.http.get<Listing[]>(`${this.apiUrl}/search`, { params }).pipe(\r\n                tap(listings => {\r\n                    console.log('📥 Search results:', listings); // Debug log\r\n                    // Cache the search results\r\n                    listings.forEach(listing => {\r\n                        this.indexedDBService.put('listings', listing).subscribe();\r\n                    });\r\n                }),\r\n                catchError(error => {\r\n                    console.error('❌ Search error:', error); // Debug log\r\n                    this.notificationService.show('Error searching listings. Using offline search.', 'error');\r\n                    return this.searchOfflineListings(query, priceRange);\r\n                })\r\n            );\r\n        } else {\r\n            return this.searchOfflineListings(query, priceRange);\r\n        }\r\n    }\r\n\r\n    private searchOfflineListings(query: string, priceRange?: PriceRange): Observable<Listing[]> {\r\n        return this.indexedDBService.getAll<Listing>('listings').pipe(\r\n            map(listings => {\r\n                const searchLower = query.toLowerCase();\r\n                let filteredListings = listings.filter(listing =>\r\n                    listing.title.toLowerCase().includes(searchLower) ||\r\n                    (listing.description && listing.description.toLowerCase().includes(searchLower)) ||\r\n                    listing.measurement.toLowerCase().includes(searchLower) ||\r\n                    listing.quality.toLowerCase().includes(searchLower)\r\n                );\r\n\r\n                // ✅ FIXED: Apply price range filter\r\n                if (priceRange) {\r\n                    filteredListings = filteredListings.filter(listing =>\r\n                        listing.price >= priceRange.min && listing.price <= priceRange.max\r\n                    );\r\n                }\r\n\r\n                return filteredListings;\r\n            })\r\n        );\r\n    }\r\n\r\n    // Helper method to convert FormData to object for offline queue\r\n    private formDataToObject(formData: FormData): any {\r\n        const obj: any = {};\r\n        formData.forEach((value, key) => {\r\n            if (value instanceof File) {\r\n                // For files, you might want to store metadata only\r\n                // In a full implementation, you'd handle file storage separately\r\n                if (!obj.files) obj.files = [];\r\n                obj.files.push({\r\n                    name: value.name,\r\n                    type: value.type,\r\n                    size: value.size\r\n                });\r\n            } else {\r\n                obj[key] = value;\r\n            }\r\n        });\r\n        return obj;\r\n    }\r\n\r\n    // Error handling method\r\n    private handleError(error: HttpErrorResponse) {\r\n        console.error('API Error Response:', error);\r\n\r\n        let errorMessage = 'Unknown error occurred';\r\n\r\n        // Try to extract more detailed error information\r\n        if (error.error instanceof ErrorEvent) {\r\n            // Client-side error\r\n            errorMessage = `Error: ${error.error.message}`;\r\n        } else {\r\n            // Server-side error\r\n            errorMessage = `Error Code: ${error.status}\\nMessage: ${error.message}`;\r\n\r\n            // Try to extract more detailed error from response body\r\n            if (error.error) {\r\n                if (typeof error.error === 'string') {\r\n                    errorMessage += `\\nDetails: ${error.error}`;\r\n                } else if (error.error.errors) {\r\n                    // This extracts validation errors from ASP.NET Core response\r\n                    errorMessage += '\\nValidation Errors:';\r\n                    for (const key in error.error.errors) {\r\n                        if (error.error.errors.hasOwnProperty(key)) {\r\n                            errorMessage += `\\n- ${key}: ${error.error.errors[key].join(', ')}`;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        console.error(errorMessage);\r\n        return throwError(() => new Error(errorMessage));\r\n    }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}