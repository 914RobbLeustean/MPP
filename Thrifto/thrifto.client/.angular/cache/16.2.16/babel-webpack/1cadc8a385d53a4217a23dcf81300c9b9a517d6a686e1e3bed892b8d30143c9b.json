{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { throwError, of } from 'rxjs';\nimport { catchError, tap, map, switchMap } from 'rxjs/operators';\nimport { OperationType } from './offline-queue.service';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./network.service\";\nimport * as i3 from \"./indexed-db.service\";\nimport * as i4 from \"./offline-queue.service\";\nimport * as i5 from \"./notification.service\";\nimport * as i6 from \"./auth.service\";\nexport class ListingService {\n  constructor(http, networkService, indexedDBService, offlineQueueService, notificationService, authService) {\n    this.http = http;\n    this.networkService = networkService;\n    this.indexedDBService = indexedDBService;\n    this.offlineQueueService = offlineQueueService;\n    this.notificationService = notificationService;\n    this.authService = authService;\n    this.apiUrl = `${environment.apiUrl}/listings`;\n  }\n  // Update the method signature to return the paginated result\n  getListings(params = {}) {\n    let httpParams = new HttpParams();\n    Object.keys(params).forEach(key => {\n      if (params[key] !== null && params[key] !== undefined) {\n        httpParams = httpParams.set(key, params[key]);\n      }\n    });\n    // Check if online\n    if (this.networkService.isOnline) {\n      // Change the response type to match our new structure\n      return this.http.get(this.apiUrl, {\n        params: httpParams\n      }).pipe(tap(response => {\n        // Cache the listings\n        response.items.forEach(listing => {\n          this.indexedDBService.put('listings', listing).subscribe();\n        });\n      }), catchError(error => {\n        this.notificationService.show('Error loading listings from server. Using offline data.', 'error');\n        return this.getOfflineListings(params);\n      }));\n    } else {\n      // If offline, use cached data\n      return this.getOfflineListings(params);\n    }\n  }\n  getOfflineListings(params) {\n    return this.indexedDBService.getAll('listings').pipe(map(listings => {\n      // Apply basic filters if params are present\n      let filteredListings = listings;\n      if (params.quality) {\n        filteredListings = filteredListings.filter(l => l.quality === params.quality);\n      }\n      if (params.search) {\n        const searchLower = params.search.toLowerCase();\n        filteredListings = filteredListings.filter(l => l.title.toLowerCase().includes(searchLower) || l.description && l.description.toLowerCase().includes(searchLower));\n      }\n      // Get total count before pagination\n      const totalCount = filteredListings.length;\n      // Handle pagination if provided\n      if (params.page && params.pageSize) {\n        const startIndex = (params.page - 1) * params.pageSize;\n        filteredListings = filteredListings.slice(startIndex, startIndex + params.pageSize);\n      }\n      // Sort by newest first (default)\n      filteredListings = filteredListings.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n      return {\n        items: filteredListings,\n        totalCount: totalCount\n      };\n    }), catchError(error => {\n      this.notificationService.show('Error loading offline listings', 'error');\n      return of({\n        items: [],\n        totalCount: 0\n      });\n    }));\n  }\n  getNewListings(count = 8) {\n    if (this.networkService.isOnline) {\n      return this.http.get(`${this.apiUrl}/new`, {\n        params: new HttpParams().set('count', count.toString())\n      }).pipe(tap(listings => {\n        // Cache the listings\n        listings.forEach(listing => {\n          this.indexedDBService.put('listings', listing).subscribe();\n        });\n      }), catchError(error => {\n        this.notificationService.show('Error loading new listings from server. Using offline data.', 'error');\n        return this.getOfflineNewListings(count);\n      }));\n    } else {\n      return this.getOfflineNewListings(count);\n    }\n  }\n  getOfflineNewListings(count) {\n    return this.indexedDBService.getAll('listings').pipe(map(listings => {\n      // Sort by creation date (newest first) and take the specified count\n      return listings.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()).slice(0, count);\n    }));\n  }\n  getListingById(id) {\n    // ✅ Skip network check for faster response\n    if (this.networkService.isOnline) {\n      return this.http.get(`${this.apiUrl}/${id}`).pipe(tap(listing => {\n        // ✅ Cache asynchronously (non-blocking)\n        this.indexedDBService.put('listings', listing).subscribe();\n      }), catchError(error => {\n        // ✅ Fallback to offline data only on error\n        return this.getOfflineListing(id);\n      }));\n    } else {\n      return this.getOfflineListing(id);\n    }\n  }\n  getOfflineListing(id) {\n    return this.indexedDBService.get('listings', id).pipe(switchMap(listing => {\n      if (listing) {\n        return of(listing);\n      } else {\n        this.notificationService.show('Listing not found in offline storage', 'error');\n        return throwError(() => new Error('Listing not found in offline storage'));\n      }\n    }));\n  }\n  getUserListings(userId) {\n    if (this.networkService.isOnline) {\n      return this.http.get(`${this.apiUrl}/user/${userId}`).pipe(tap(listings => {\n        // Cache the listings\n        listings.forEach(listing => {\n          this.indexedDBService.put('listings', listing).subscribe();\n        });\n      }), switchMap(onlineListings => {\n        // Get offline listings as well and combine\n        return this.getOfflineUserListings(userId).pipe(map(offlineListings => {\n          // Filter out any offline listings that were already synced and exist in onlineListings\n          const filteredOfflineListings = offlineListings.filter(offline =>\n          // Only include if no online listing with matching ID exists\n          // (offline listings have negative IDs so there shouldn't be conflicts)\n          !onlineListings.some(online => online.id === offline.id));\n          // Combine online and offline listings\n          return [...onlineListings, ...filteredOfflineListings];\n        }));\n      }), catchError(error => {\n        this.notificationService.show('Error loading user listings from server. Using offline data.', 'error');\n        return this.getOfflineUserListings(userId);\n      }));\n    } else {\n      return this.getOfflineUserListings(userId);\n    }\n  }\n  getOfflineUserListings(userId) {\n    return this.indexedDBService.getAll('listings').pipe(map(listings => {\n      // Filter to only include listings from this user (including temporary IDs) \n      // and not soft-deleted ones\n      return listings.filter(listing => listing.userId === userId && !listing.isDeleted);\n    }));\n  }\n  createListing(formData) {\n    if (this.networkService.isOnline) {\n      return this.http.post(this.apiUrl, formData).pipe(tap(listing => {\n        // Cache the new listing\n        this.indexedDBService.put('listings', listing).subscribe();\n      }), catchError(error => {\n        this.notificationService.show('Error creating listing on server. Queuing for offline sync.', 'error');\n        return this.createOfflineListing(formData);\n      }));\n    } else {\n      return this.createOfflineListing(formData);\n    }\n  }\n  createOfflineListing(formData) {\n    // Extract data from FormData\n    const tempId = -Math.floor(Math.random() * 1000000); // Negative ID to indicate it's temporary\n    // Convert FormData to a regular object\n    const listingData = {};\n    formData.forEach((value, key) => {\n      // Skip file objects for now in the temporary listing object\n      if (!(value instanceof File)) {\n        listingData[key] = value;\n      }\n    });\n    // Get current user info\n    const currentUser = this.authService.getCurrentUser();\n    if (!currentUser) {\n      return throwError(() => new Error('User must be logged in to create listings'));\n    }\n    // Photos would need special handling for offline storage\n    // For simplicity in this example, we're skipping photo uploads in offline mode\n    // In a full implementation, you could convert the File objects to data URLs\n    // Create a temporary listing object\n    const tempListing = {\n      id: tempId,\n      title: listingData.title || 'Untitled',\n      measurement: listingData.measurement || '',\n      quality: listingData.quality || '',\n      price: parseFloat(listingData.price) || 0,\n      description: listingData.description || '',\n      createdAt: new Date(),\n      userId: currentUser.id,\n      userName: currentUser.username || `${currentUser.firstName} ${currentUser.lastName}`,\n      photoUrls: [],\n      isOfflinePending: true\n    };\n    // Store in IndexedDB\n    return this.indexedDBService.put('listings', tempListing).pipe(switchMap(savedListing => {\n      // Queue operation for later sync\n      return this.offlineQueueService.queueOperation({\n        entityType: 'listing',\n        operationType: OperationType.CREATE,\n        payload: this.formDataToObject(formData),\n        timestamp: Date.now(),\n        tempId: tempId\n      }).pipe(map(() => {\n        this.notificationService.show('Listing saved offline and will sync when online', 'info');\n        return savedListing;\n      }));\n    }));\n  }\n  updateListing(id, formData) {\n    if (this.networkService.isOnline) {\n      return this.http.put(`${this.apiUrl}/${id}`, formData).pipe(tap(listing => {\n        // Update the cache\n        this.indexedDBService.put('listings', listing).subscribe();\n      }), catchError(error => {\n        this.notificationService.show('Error updating listing on server. Queuing for offline sync.', 'error');\n        return this.updateOfflineListing(id, formData);\n      }));\n    } else {\n      return this.updateOfflineListing(id, formData);\n    }\n  }\n  updateOfflineListing(id, formData) {\n    // First get the existing listing\n    return this.indexedDBService.get('listings', id).pipe(switchMap(existingListing => {\n      if (!existingListing) {\n        return throwError(() => new Error('Listing not found in offline storage'));\n      }\n      // Convert FormData to a regular object\n      const updateData = {};\n      formData.forEach((value, key) => {\n        // Skip file objects for now in the temporary update object\n        if (!(value instanceof File)) {\n          updateData[key] = value;\n        }\n      });\n      // Update the listing with new values\n      const updatedListing = {\n        ...existingListing,\n        title: updateData.title || existingListing.title,\n        measurement: updateData.measurement || existingListing.measurement,\n        quality: updateData.quality || existingListing.quality,\n        price: parseFloat(updateData.price) || existingListing.price,\n        description: updateData.description || existingListing.description,\n        isOfflinePending: true\n      };\n      // Store the updated listing\n      return this.indexedDBService.put('listings', updatedListing).pipe(switchMap(savedListing => {\n        // Queue the operation for later sync\n        return this.offlineQueueService.queueOperation({\n          entityType: 'listing',\n          entityId: id,\n          operationType: OperationType.UPDATE,\n          payload: this.formDataToObject(formData),\n          timestamp: Date.now()\n        }).pipe(map(() => {\n          this.notificationService.show('Listing updated offline and will sync when online', 'info');\n          return savedListing;\n        }));\n      }));\n    }));\n  }\n  deleteListing(id) {\n    if (this.networkService.isOnline) {\n      return this.http.delete(`${this.apiUrl}/${id}`).pipe(tap(() => {\n        // Remove from cache\n        this.indexedDBService.delete('listings', id).subscribe();\n      }), catchError(error => {\n        this.notificationService.show('Error deleting listing from server. Queuing for offline sync.', 'error');\n        return this.deleteOfflineListing(id);\n      }));\n    } else {\n      return this.deleteOfflineListing(id);\n    }\n  }\n  deleteOfflineListing(id) {\n    // For offline deletes, we have two scenarios:\n    // 1. If the listing was created offline (has negative ID), we can just remove it\n    // 2. If the listing exists on the server, we mark it for deletion and queue the operation\n    return this.indexedDBService.get('listings', id).pipe(switchMap(listing => {\n      if (!listing) {\n        return throwError(() => new Error('Listing not found in offline storage'));\n      }\n      // If this is a temporary ID (negative), it was created offline\n      if (id < 0) {\n        // Find and remove any pending create operations for this listing\n        return this.offlineQueueService.getPendingOperations().pipe(switchMap(operations => {\n          const createOp = operations.find(op => op.operationType === OperationType.CREATE && op.entityType === 'listing' && op.tempId === id);\n          if (createOp && createOp.id) {\n            // Remove the create operation from the queue\n            return this.offlineQueueService.removePendingOperation(createOp.id).pipe(switchMap(() => this.indexedDBService.delete('listings', id)), map(() => true));\n          } else {\n            // Just remove from IndexedDB\n            return this.indexedDBService.delete('listings', id).pipe(map(() => true));\n          }\n        }));\n      } else {\n        // This is a server-side listing - mark as deleted locally\n        listing.isDeleted = true;\n        listing.isOfflinePending = true;\n        return this.indexedDBService.put('listings', listing).pipe(switchMap(() => {\n          // Queue the delete operation\n          return this.offlineQueueService.queueOperation({\n            entityType: 'listing',\n            entityId: id,\n            operationType: OperationType.DELETE,\n            payload: null,\n            timestamp: Date.now()\n          });\n        }), map(() => {\n          this.notificationService.show('Listing marked for deletion and will be removed when online', 'info');\n          return true;\n        }));\n      }\n    }));\n  }\n  searchListings(query) {\n    if (this.networkService.isOnline) {\n      return this.http.get(`${this.apiUrl}/search`, {\n        params: new HttpParams().set('q', query)\n      }).pipe(tap(listings => {\n        // Cache the search results\n        listings.forEach(listing => {\n          this.indexedDBService.put('listings', listing).subscribe();\n        });\n      }), catchError(error => {\n        this.notificationService.show('Error searching listings. Using offline search.', 'error');\n        return this.searchOfflineListings(query);\n      }));\n    } else {\n      return this.searchOfflineListings(query);\n    }\n  }\n  searchOfflineListings(query) {\n    return this.indexedDBService.getAll('listings').pipe(map(listings => {\n      const searchLower = query.toLowerCase();\n      return listings.filter(listing => listing.title.toLowerCase().includes(searchLower) || listing.description && listing.description.toLowerCase().includes(searchLower) || listing.measurement.toLowerCase().includes(searchLower) || listing.quality.toLowerCase().includes(searchLower));\n    }));\n  }\n  // Helper method to convert FormData to object for offline queue\n  formDataToObject(formData) {\n    const obj = {};\n    formData.forEach((value, key) => {\n      if (value instanceof File) {\n        // For files, you might want to store metadata only\n        // In a full implementation, you'd handle file storage separately\n        if (!obj.files) obj.files = [];\n        obj.files.push({\n          name: value.name,\n          type: value.type,\n          size: value.size\n        });\n      } else {\n        obj[key] = value;\n      }\n    });\n    return obj;\n  }\n  // Error handling method\n  handleError(error) {\n    console.error('API Error Response:', error);\n    let errorMessage = 'Unknown error occurred';\n    // Try to extract more detailed error information\n    if (error.error instanceof ErrorEvent) {\n      // Client-side error\n      errorMessage = `Error: ${error.error.message}`;\n    } else {\n      // Server-side error\n      errorMessage = `Error Code: ${error.status}\\nMessage: ${error.message}`;\n      // Try to extract more detailed error from response body\n      if (error.error) {\n        if (typeof error.error === 'string') {\n          errorMessage += `\\nDetails: ${error.error}`;\n        } else if (error.error.errors) {\n          // This extracts validation errors from ASP.NET Core response\n          errorMessage += '\\nValidation Errors:';\n          for (const key in error.error.errors) {\n            if (error.error.errors.hasOwnProperty(key)) {\n              errorMessage += `\\n- ${key}: ${error.error.errors[key].join(', ')}`;\n            }\n          }\n        }\n      }\n    }\n    console.error(errorMessage);\n    return throwError(() => new Error(errorMessage));\n  }\n  static {\n    this.ɵfac = function ListingService_Factory(t) {\n      return new (t || ListingService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.NetworkService), i0.ɵɵinject(i3.IndexedDBService), i0.ɵɵinject(i4.OfflineQueueService), i0.ɵɵinject(i5.NotificationService), i0.ɵɵinject(i6.AuthService));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ListingService,\n      factory: ListingService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["HttpParams","throwError","of","catchError","tap","map","switchMap","OperationType","environment","ListingService","constructor","http","networkService","indexedDBService","offlineQueueService","notificationService","authService","apiUrl","getListings","params","httpParams","Object","keys","forEach","key","undefined","set","isOnline","get","pipe","response","items","listing","put","subscribe","error","show","getOfflineListings","getAll","listings","filteredListings","quality","filter","l","search","searchLower","toLowerCase","title","includes","description","totalCount","length","page","pageSize","startIndex","slice","sort","a","b","Date","createdAt","getTime","getNewListings","count","toString","getOfflineNewListings","getListingById","id","getOfflineListing","Error","getUserListings","userId","onlineListings","getOfflineUserListings","offlineListings","filteredOfflineListings","offline","some","online","isDeleted","createListing","formData","post","createOfflineListing","tempId","Math","floor","random","listingData","value","File","currentUser","getCurrentUser","tempListing","measurement","price","parseFloat","userName","username","firstName","lastName","photoUrls","isOfflinePending","savedListing","queueOperation","entityType","operationType","CREATE","payload","formDataToObject","timestamp","now","updateListing","updateOfflineListing","existingListing","updateData","updatedListing","entityId","UPDATE","deleteListing","delete","deleteOfflineListing","getPendingOperations","operations","createOp","find","op","removePendingOperation","DELETE","searchListings","query","searchOfflineListings","obj","files","push","name","type","size","handleError","console","errorMessage","ErrorEvent","message","status","errors","hasOwnProperty","join","i0","ɵɵinject","i1","HttpClient","i2","NetworkService","i3","IndexedDBService","i4","OfflineQueueService","i5","NotificationService","i6","AuthService","factory","ɵfac","providedIn"],"sources":["C:\\Users\\leust\\source\\repos\\MPP-main\\Thrifto\\thrifto.client\\src\\app\\services\\listing.service.ts"],"sourcesContent":["// src/app/services/listing.service.ts\r\nimport { Injectable } from '@angular/core';\r\nimport { HttpClient, HttpParams, HttpErrorResponse } from '@angular/common/http';\r\nimport { Observable, throwError, of } from 'rxjs';\r\nimport { catchError, tap, map, switchMap } from 'rxjs/operators';\r\nimport { Listing } from '../models/listing.model';\r\nimport { NetworkService, ConnectionStatus } from './network.service';\r\nimport { IndexedDBService } from './indexed-db.service';\r\nimport { OfflineQueueService, OperationType } from './offline-queue.service';\r\nimport { NotificationService } from './notification.service';\r\nimport { AuthService } from './auth.service';\r\nimport { environment } from '../../environments/environment';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class ListingService {\r\n  private apiUrl = `${environment.apiUrl}/listings`;\r\n\r\n  constructor(\r\n    private http: HttpClient,\r\n    private networkService: NetworkService,\r\n    private indexedDBService: IndexedDBService,\r\n    private offlineQueueService: OfflineQueueService,\r\n    private notificationService: NotificationService,\r\n      private authService: AuthService\r\n  ) { }\r\n\r\n  // Update the method signature to return the paginated result\r\n  getListings(params: any = {}): Observable<{ items: Listing[], totalCount: number }> {\r\n    let httpParams = new HttpParams();\r\n    Object.keys(params).forEach(key => {\r\n      if (params[key] !== null && params[key] !== undefined) {\r\n        httpParams = httpParams.set(key, params[key]);\r\n      }\r\n    });\r\n\r\n    // Check if online\r\n    if (this.networkService.isOnline) {\r\n      // Change the response type to match our new structure\r\n      return this.http.get<{ items: Listing[], totalCount: number }>(this.apiUrl, { params: httpParams }).pipe(\r\n        tap(response => {\r\n          // Cache the listings\r\n          response.items.forEach(listing => {\r\n            this.indexedDBService.put('listings', listing).subscribe();\r\n          });\r\n        }),\r\n        catchError(error => {\r\n          this.notificationService.show('Error loading listings from server. Using offline data.', 'error');\r\n          return this.getOfflineListings(params);\r\n        })\r\n      );\r\n    } else {\r\n      // If offline, use cached data\r\n      return this.getOfflineListings(params);\r\n    }\r\n  }\r\n\r\n  private getOfflineListings(params: any): Observable<{ items: Listing[], totalCount: number }> {\r\n    return this.indexedDBService.getAll<Listing>('listings').pipe(\r\n      map(listings => {\r\n        // Apply basic filters if params are present\r\n        let filteredListings = listings;\r\n\r\n        if (params.quality) {\r\n          filteredListings = filteredListings.filter(l => l.quality === params.quality);\r\n        }\r\n\r\n        if (params.search) {\r\n          const searchLower = params.search.toLowerCase();\r\n          filteredListings = filteredListings.filter(l =>\r\n            l.title.toLowerCase().includes(searchLower) ||\r\n            (l.description && l.description.toLowerCase().includes(searchLower))\r\n          );\r\n        }\r\n\r\n        // Get total count before pagination\r\n        const totalCount = filteredListings.length;\r\n\r\n        // Handle pagination if provided\r\n        if (params.page && params.pageSize) {\r\n          const startIndex = (params.page - 1) * params.pageSize;\r\n          filteredListings = filteredListings.slice(startIndex, startIndex + params.pageSize);\r\n        }\r\n\r\n        // Sort by newest first (default)\r\n        filteredListings = filteredListings.sort((a, b) =>\r\n          new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\r\n        );\r\n\r\n        return {\r\n          items: filteredListings,\r\n          totalCount: totalCount\r\n        };\r\n      }),\r\n      catchError(error => {\r\n        this.notificationService.show('Error loading offline listings', 'error');\r\n        return of({ items: [], totalCount: 0 });\r\n      })\r\n    );\r\n  }\r\n\r\n  getNewListings(count: number = 8): Observable<Listing[]> {\r\n    if (this.networkService.isOnline) {\r\n      return this.http.get<Listing[]>(`${this.apiUrl}/new`, {\r\n        params: new HttpParams().set('count', count.toString())\r\n      }).pipe(\r\n        tap(listings => {\r\n          // Cache the listings\r\n          listings.forEach(listing => {\r\n            this.indexedDBService.put('listings', listing).subscribe();\r\n          });\r\n        }),\r\n        catchError(error => {\r\n          this.notificationService.show('Error loading new listings from server. Using offline data.', 'error');\r\n          return this.getOfflineNewListings(count);\r\n        })\r\n      );\r\n    } else {\r\n      return this.getOfflineNewListings(count);\r\n    }\r\n  }\r\n\r\n  private getOfflineNewListings(count: number): Observable<Listing[]> {\r\n    return this.indexedDBService.getAll<Listing>('listings').pipe(\r\n      map(listings => {\r\n        // Sort by creation date (newest first) and take the specified count\r\n        return listings\r\n          .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())\r\n          .slice(0, count);\r\n      })\r\n    );\r\n  }\r\n\r\n    getListingById(id: number): Observable<Listing> {\r\n        // ✅ Skip network check for faster response\r\n        if (this.networkService.isOnline) {\r\n            return this.http.get<Listing>(`${this.apiUrl}/${id}`).pipe(\r\n                tap(listing => {\r\n                    // ✅ Cache asynchronously (non-blocking)\r\n                    this.indexedDBService.put('listings', listing).subscribe();\r\n                }),\r\n                catchError(error => {\r\n                    // ✅ Fallback to offline data only on error\r\n                    return this.getOfflineListing(id);\r\n                })\r\n            );\r\n        } else {\r\n            return this.getOfflineListing(id);\r\n        }\r\n    }\r\n\r\n  private getOfflineListing(id: number): Observable<Listing> {\r\n    return this.indexedDBService.get<Listing>('listings', id).pipe(\r\n      switchMap(listing => {\r\n        if (listing) {\r\n          return of(listing);\r\n        } else {\r\n          this.notificationService.show('Listing not found in offline storage', 'error');\r\n          return throwError(() => new Error('Listing not found in offline storage'));\r\n        }\r\n      })\r\n    );\r\n  }\r\n\r\n  getUserListings(userId: string): Observable<Listing[]> {\r\n    if (this.networkService.isOnline) {\r\n      return this.http.get<Listing[]>(`${this.apiUrl}/user/${userId}`).pipe(\r\n        tap(listings => {\r\n          // Cache the listings\r\n          listings.forEach(listing => {\r\n            this.indexedDBService.put('listings', listing).subscribe();\r\n          });\r\n        }),\r\n        switchMap(onlineListings => {\r\n          // Get offline listings as well and combine\r\n          return this.getOfflineUserListings(userId).pipe(\r\n            map(offlineListings => {\r\n              // Filter out any offline listings that were already synced and exist in onlineListings\r\n              const filteredOfflineListings = offlineListings.filter(offline =>\r\n                // Only include if no online listing with matching ID exists\r\n                // (offline listings have negative IDs so there shouldn't be conflicts)\r\n                !onlineListings.some(online => online.id === offline.id)\r\n              );\r\n              // Combine online and offline listings\r\n              return [...onlineListings, ...filteredOfflineListings];\r\n            })\r\n          );\r\n        }),\r\n        catchError(error => {\r\n          this.notificationService.show('Error loading user listings from server. Using offline data.', 'error');\r\n          return this.getOfflineUserListings(userId);\r\n        })\r\n      );\r\n    } else {\r\n      return this.getOfflineUserListings(userId);\r\n    }\r\n  }\r\n\r\n  private getOfflineUserListings(userId: string): Observable<Listing[]> {\r\n    return this.indexedDBService.getAll<Listing>('listings').pipe(\r\n      map(listings => {\r\n        // Filter to only include listings from this user (including temporary IDs) \r\n        // and not soft-deleted ones\r\n        return listings.filter(listing =>\r\n          listing.userId === userId &&\r\n          !listing.isDeleted\r\n        );\r\n      })\r\n    );\r\n  }\r\n\r\n  createListing(formData: FormData): Observable<Listing> {\r\n    if (this.networkService.isOnline) {\r\n      return this.http.post<Listing>(this.apiUrl, formData).pipe(\r\n        tap(listing => {\r\n          // Cache the new listing\r\n          this.indexedDBService.put('listings', listing).subscribe();\r\n        }),\r\n        catchError(error => {\r\n          this.notificationService.show('Error creating listing on server. Queuing for offline sync.', 'error');\r\n          return this.createOfflineListing(formData);\r\n        })\r\n      );\r\n    } else {\r\n      return this.createOfflineListing(formData);\r\n    }\r\n  }\r\n\r\n  private createOfflineListing(formData: FormData): Observable<Listing> {\r\n    // Extract data from FormData\r\n    const tempId = -Math.floor(Math.random() * 1000000); // Negative ID to indicate it's temporary\r\n\r\n    // Convert FormData to a regular object\r\n    const listingData: any = {};\r\n    formData.forEach((value, key) => {\r\n      // Skip file objects for now in the temporary listing object\r\n      if (!(value instanceof File)) {\r\n        listingData[key] = value;\r\n      }\r\n    });\r\n\r\n    // Get current user info\r\n    const currentUser = this.authService.getCurrentUser();\r\n    if (!currentUser) {\r\n      return throwError(() => new Error('User must be logged in to create listings'));\r\n    }\r\n\r\n    // Photos would need special handling for offline storage\r\n    // For simplicity in this example, we're skipping photo uploads in offline mode\r\n    // In a full implementation, you could convert the File objects to data URLs\r\n\r\n    // Create a temporary listing object\r\n    const tempListing: Listing = {\r\n      id: tempId,\r\n      title: listingData.title || 'Untitled',\r\n      measurement: listingData.measurement || '',\r\n      quality: listingData.quality || '',\r\n      price: parseFloat(listingData.price) || 0,\r\n      description: listingData.description || '',\r\n      createdAt: new Date(),\r\n      userId: currentUser.id, // Use the actual user ID\r\n      userName: currentUser.username || `${currentUser.firstName} ${currentUser.lastName}`, // Use real username or full name\r\n      photoUrls: [], // No photos for offline created listing\r\n      isOfflinePending: true\r\n    };\r\n\r\n    // Store in IndexedDB\r\n    return this.indexedDBService.put<Listing>('listings', tempListing).pipe(\r\n      switchMap(savedListing => {\r\n        // Queue operation for later sync\r\n        return this.offlineQueueService.queueOperation({\r\n          entityType: 'listing',\r\n          operationType: OperationType.CREATE,\r\n          payload: this.formDataToObject(formData),\r\n          timestamp: Date.now(),\r\n          tempId: tempId\r\n        }).pipe(\r\n          map(() => {\r\n            this.notificationService.show('Listing saved offline and will sync when online', 'info');\r\n            return savedListing;\r\n          })\r\n        );\r\n      })\r\n    );\r\n  }\r\n\r\n  updateListing(id: number, formData: FormData): Observable<Listing> {\r\n    if (this.networkService.isOnline) {\r\n      return this.http.put<Listing>(`${this.apiUrl}/${id}`, formData).pipe(\r\n        tap(listing => {\r\n          // Update the cache\r\n          this.indexedDBService.put('listings', listing).subscribe();\r\n        }),\r\n        catchError(error => {\r\n          this.notificationService.show('Error updating listing on server. Queuing for offline sync.', 'error');\r\n          return this.updateOfflineListing(id, formData);\r\n        })\r\n      );\r\n    } else {\r\n      return this.updateOfflineListing(id, formData);\r\n    }\r\n  }\r\n\r\n  private updateOfflineListing(id: number, formData: FormData): Observable<Listing> {\r\n    // First get the existing listing\r\n    return this.indexedDBService.get<Listing>('listings', id).pipe(\r\n      switchMap(existingListing => {\r\n        if (!existingListing) {\r\n          return throwError(() => new Error('Listing not found in offline storage'));\r\n        }\r\n\r\n        // Convert FormData to a regular object\r\n        const updateData: any = {};\r\n        formData.forEach((value, key) => {\r\n          // Skip file objects for now in the temporary update object\r\n          if (!(value instanceof File)) {\r\n            updateData[key] = value;\r\n          }\r\n        });\r\n\r\n        // Update the listing with new values\r\n        const updatedListing: Listing = {\r\n          ...existingListing,\r\n          title: updateData.title || existingListing.title,\r\n          measurement: updateData.measurement || existingListing.measurement,\r\n          quality: updateData.quality || existingListing.quality,\r\n          price: parseFloat(updateData.price) || existingListing.price,\r\n          description: updateData.description || existingListing.description,\r\n          isOfflinePending: true\r\n        };\r\n\r\n        // Store the updated listing\r\n        return this.indexedDBService.put<Listing>('listings', updatedListing).pipe(\r\n          switchMap(savedListing => {\r\n            // Queue the operation for later sync\r\n            return this.offlineQueueService.queueOperation({\r\n              entityType: 'listing',\r\n              entityId: id,\r\n              operationType: OperationType.UPDATE,\r\n              payload: this.formDataToObject(formData),\r\n              timestamp: Date.now()\r\n            }).pipe(\r\n              map(() => {\r\n                this.notificationService.show('Listing updated offline and will sync when online', 'info');\r\n                return savedListing;\r\n              })\r\n            );\r\n          })\r\n        );\r\n      })\r\n    );\r\n  }\r\n\r\n  deleteListing(id: number): Observable<any> {\r\n    if (this.networkService.isOnline) {\r\n      return this.http.delete(`${this.apiUrl}/${id}`).pipe(\r\n        tap(() => {\r\n          // Remove from cache\r\n          this.indexedDBService.delete('listings', id).subscribe();\r\n        }),\r\n        catchError(error => {\r\n          this.notificationService.show('Error deleting listing from server. Queuing for offline sync.', 'error');\r\n          return this.deleteOfflineListing(id);\r\n        })\r\n      );\r\n    } else {\r\n      return this.deleteOfflineListing(id);\r\n    }\r\n  }\r\n\r\n  private deleteOfflineListing(id: number): Observable<boolean> {\r\n    // For offline deletes, we have two scenarios:\r\n    // 1. If the listing was created offline (has negative ID), we can just remove it\r\n    // 2. If the listing exists on the server, we mark it for deletion and queue the operation\r\n\r\n    return this.indexedDBService.get<Listing>('listings', id).pipe(\r\n      switchMap(listing => {\r\n        if (!listing) {\r\n          return throwError(() => new Error('Listing not found in offline storage'));\r\n        }\r\n\r\n        // If this is a temporary ID (negative), it was created offline\r\n        if (id < 0) {\r\n          // Find and remove any pending create operations for this listing\r\n          return this.offlineQueueService.getPendingOperations().pipe(\r\n            switchMap(operations => {\r\n              const createOp = operations.find(op =>\r\n                op.operationType === OperationType.CREATE &&\r\n                op.entityType === 'listing' &&\r\n                op.tempId === id\r\n              );\r\n\r\n              if (createOp && createOp.id) {\r\n                // Remove the create operation from the queue\r\n                return this.offlineQueueService.removePendingOperation(createOp.id).pipe(\r\n                  switchMap(() => this.indexedDBService.delete('listings', id)),\r\n                  map(() => true)\r\n                );\r\n              } else {\r\n                // Just remove from IndexedDB\r\n                return this.indexedDBService.delete('listings', id).pipe(\r\n                  map(() => true)\r\n                );\r\n              }\r\n            })\r\n          );\r\n        } else {\r\n          // This is a server-side listing - mark as deleted locally\r\n          listing.isDeleted = true;\r\n          listing.isOfflinePending = true;\r\n\r\n          return this.indexedDBService.put('listings', listing).pipe(\r\n            switchMap(() => {\r\n              // Queue the delete operation\r\n              return this.offlineQueueService.queueOperation({\r\n                entityType: 'listing',\r\n                entityId: id,\r\n                operationType: OperationType.DELETE,\r\n                payload: null,\r\n                timestamp: Date.now()\r\n              });\r\n            }),\r\n            map(() => {\r\n              this.notificationService.show('Listing marked for deletion and will be removed when online', 'info');\r\n              return true;\r\n            })\r\n          );\r\n        }\r\n      })\r\n    );\r\n  }\r\n\r\n  searchListings(query: string): Observable<Listing[]> {\r\n    if (this.networkService.isOnline) {\r\n      return this.http.get<Listing[]>(`${this.apiUrl}/search`, {\r\n        params: new HttpParams().set('q', query)\r\n      }).pipe(\r\n        tap(listings => {\r\n          // Cache the search results\r\n          listings.forEach(listing => {\r\n            this.indexedDBService.put('listings', listing).subscribe();\r\n          });\r\n        }),\r\n        catchError(error => {\r\n          this.notificationService.show('Error searching listings. Using offline search.', 'error');\r\n          return this.searchOfflineListings(query);\r\n        })\r\n      );\r\n    } else {\r\n      return this.searchOfflineListings(query);\r\n    }\r\n  }\r\n\r\n  private searchOfflineListings(query: string): Observable<Listing[]> {\r\n    return this.indexedDBService.getAll<Listing>('listings').pipe(\r\n      map(listings => {\r\n        const searchLower = query.toLowerCase();\r\n        return listings.filter(listing =>\r\n          listing.title.toLowerCase().includes(searchLower) ||\r\n          (listing.description && listing.description.toLowerCase().includes(searchLower)) ||\r\n          listing.measurement.toLowerCase().includes(searchLower) ||\r\n          listing.quality.toLowerCase().includes(searchLower)\r\n        );\r\n      })\r\n    );\r\n  }\r\n\r\n  // Helper method to convert FormData to object for offline queue\r\n  private formDataToObject(formData: FormData): any {\r\n    const obj: any = {};\r\n    formData.forEach((value, key) => {\r\n      if (value instanceof File) {\r\n        // For files, you might want to store metadata only\r\n        // In a full implementation, you'd handle file storage separately\r\n        if (!obj.files) obj.files = [];\r\n        obj.files.push({\r\n          name: value.name,\r\n          type: value.type,\r\n          size: value.size\r\n        });\r\n      } else {\r\n        obj[key] = value;\r\n      }\r\n    });\r\n    return obj;\r\n  }\r\n\r\n  // Error handling method\r\n  private handleError(error: HttpErrorResponse) {\r\n    console.error('API Error Response:', error);\r\n\r\n    let errorMessage = 'Unknown error occurred';\r\n\r\n    // Try to extract more detailed error information\r\n    if (error.error instanceof ErrorEvent) {\r\n      // Client-side error\r\n      errorMessage = `Error: ${error.error.message}`;\r\n    } else {\r\n      // Server-side error\r\n      errorMessage = `Error Code: ${error.status}\\nMessage: ${error.message}`;\r\n\r\n      // Try to extract more detailed error from response body\r\n      if (error.error) {\r\n        if (typeof error.error === 'string') {\r\n          errorMessage += `\\nDetails: ${error.error}`;\r\n        } else if (error.error.errors) {\r\n          // This extracts validation errors from ASP.NET Core response\r\n          errorMessage += '\\nValidation Errors:';\r\n          for (const key in error.error.errors) {\r\n            if (error.error.errors.hasOwnProperty(key)) {\r\n              errorMessage += `\\n- ${key}: ${error.error.errors[key].join(', ')}`;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    console.error(errorMessage);\r\n    return throwError(() => new Error(errorMessage));\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}