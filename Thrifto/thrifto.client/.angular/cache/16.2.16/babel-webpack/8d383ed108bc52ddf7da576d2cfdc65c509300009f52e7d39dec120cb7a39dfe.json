{"ast":null,"code":"import { throwError } from 'rxjs';\nimport { ConnectionStatus } from './network.service';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./indexed-db.service\";\nimport * as i2 from \"./network.service\";\nimport * as i3 from \"./notification.service\";\nimport * as i4 from \"@angular/common/http\";\nexport var OperationType;\n(function (OperationType) {\n  OperationType[\"CREATE\"] = \"CREATE\";\n  OperationType[\"UPDATE\"] = \"UPDATE\";\n  OperationType[\"DELETE\"] = \"DELETE\";\n})(OperationType || (OperationType = {}));\nexport class OfflineQueueService {\n  constructor(indexedDBService, networkService, notificationService, http) {\n    this.indexedDBService = indexedDBService;\n    this.networkService = networkService;\n    this.notificationService = notificationService;\n    this.http = http;\n    this.syncInProgress = false;\n    this.apiUrl = environment.apiUrl;\n    // Listen for online status to trigger sync\n    this.networkService.status$.subscribe(status => {\n      if (status === ConnectionStatus.Online && !this.syncInProgress) {\n        this.syncPendingOperations();\n      }\n    });\n  }\n  // Queue a pending operation\n  queueOperation(operation) {\n    operation.timestamp = Date.now();\n    return this.indexedDBService.put('pendingOperations', operation);\n  }\n  // Get all pending operations\n  getPendingOperations() {\n    return this.indexedDBService.getAll('pendingOperations');\n  }\n  // Remove a pending operation\n  removePendingOperation(id) {\n    return this.indexedDBService.delete('pendingOperations', id);\n  }\n  // Sync all pending operations\n  syncPendingOperations() {\n    if (this.syncInProgress || !this.networkService.isOnline) {\n      return;\n    }\n    this.syncInProgress = true;\n    this.getPendingOperations().subscribe({\n      next: operations => {\n        // CHECK: If no operations, exit silently without showing notifications\n        if (operations.length === 0) {\n          this.syncInProgress = false;\n          return; // Exit early - no notifications needed\n        }\n        // Only show notifications if there are actual operations to sync\n        this.notificationService.show('Syncing offline changes...', 'info');\n        // Sort operations by timestamp (oldest first)\n        operations.sort((a, b) => a.timestamp - b.timestamp);\n        // Process each operation sequentially\n        this.processNextOperation(operations, 0);\n      },\n      error: error => {\n        console.error('Error getting pending operations:', error);\n        this.syncInProgress = false;\n        // Only show error notification if there was actually an error\n        // Don't show for empty queue\n      }\n    });\n  }\n  // Also update the processNextOperation method to only show success notification\n  // when operations were actually processed:\n  processNextOperation(operations, index) {\n    if (index >= operations.length) {\n      this.syncInProgress = false;\n      // Only show success notification if we actually processed operations\n      if (operations.length > 0) {\n        this.notificationService.show('All changes synced successfully!', 'success');\n      }\n      return;\n    }\n    const operation = operations[index];\n    // Execute the operation based on the service and operation type\n    this.executeOperation(operation).subscribe({\n      next: () => {\n        // Operation succeeded, remove from queue\n        this.removePendingOperation(operation.id).subscribe(() => {\n          // Process next operation\n          this.processNextOperation(operations, index + 1);\n        });\n      },\n      error: error => {\n        console.error('Error syncing operation:', error);\n        // If server is down, stop syncing\n        if (!this.networkService.isOnline) {\n          this.syncInProgress = false;\n          this.notificationService.show('Network connection lost. Sync paused.', 'error');\n          return;\n        }\n        // If it's a server error, we'll try again next time\n        // For now, let's continue with the next operation\n        this.processNextOperation(operations, index + 1);\n      }\n    });\n  }\n  executeOperation(operation) {\n    switch (operation.entityType) {\n      case 'listing':\n        return this.processListingOperation(operation);\n      case 'message':\n        return this.processMessageOperation(operation);\n      default:\n        return throwError(() => new Error(`Unknown entity type: ${operation.entityType}`));\n    }\n  }\n  processListingOperation(operation) {\n    const apiUrl = `${this.apiUrl}/listings`;\n    switch (operation.operationType) {\n      case OperationType.CREATE:\n        // For create operations, we need to convert the payload to FormData\n        const createFormData = this.convertToFormData(operation.payload);\n        return this.http.post(apiUrl, createFormData);\n      case OperationType.UPDATE:\n        // For update operations, we need to convert the payload to FormData\n        const updateFormData = this.convertToFormData(operation.payload);\n        return this.http.put(`${apiUrl}/${operation.entityId}`, updateFormData);\n      case OperationType.DELETE:\n        return this.http.delete(`${apiUrl}/${operation.entityId}`);\n      default:\n        return throwError(() => new Error(`Unknown operation type: ${operation.operationType}`));\n    }\n  }\n  processMessageOperation(operation) {\n    const apiUrl = `${this.apiUrl}/chat`;\n    switch (operation.operationType) {\n      case OperationType.CREATE:\n        return this.http.post(`${apiUrl}/messages`, operation.payload);\n      default:\n        return throwError(() => new Error(`Unknown operation type: ${operation.operationType}`));\n    }\n  }\n  convertToFormData(payload) {\n    const formData = new FormData();\n    // Add all primitive fields to formData\n    for (const key in payload) {\n      if (payload.hasOwnProperty(key) && payload[key] !== null && payload[key] !== undefined) {\n        // Skip file uploads and complex objects - these need special handling\n        if (typeof payload[key] !== 'object' || payload[key] instanceof File) {\n          formData.append(key, payload[key]);\n        }\n      }\n    }\n    // Handle photos array if present\n    if (payload.photos && Array.isArray(payload.photos)) {\n      payload.photos.forEach((photo, index) => {\n        if (photo instanceof File) {\n          formData.append(`Photos`, photo);\n        }\n      });\n    }\n    return formData;\n  }\n  static {\n    this.ɵfac = function OfflineQueueService_Factory(t) {\n      return new (t || OfflineQueueService)(i0.ɵɵinject(i1.IndexedDBService), i0.ɵɵinject(i2.NetworkService), i0.ɵɵinject(i3.NotificationService), i0.ɵɵinject(i4.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: OfflineQueueService,\n      factory: OfflineQueueService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["throwError","ConnectionStatus","environment","OperationType","OfflineQueueService","constructor","indexedDBService","networkService","notificationService","http","syncInProgress","apiUrl","status$","subscribe","status","Online","syncPendingOperations","queueOperation","operation","timestamp","Date","now","put","getPendingOperations","getAll","removePendingOperation","id","delete","isOnline","next","operations","length","show","sort","a","b","processNextOperation","error","console","index","executeOperation","entityType","processListingOperation","processMessageOperation","Error","operationType","CREATE","createFormData","convertToFormData","payload","post","UPDATE","updateFormData","entityId","DELETE","formData","FormData","key","hasOwnProperty","undefined","File","append","photos","Array","isArray","forEach","photo","i0","ɵɵinject","i1","IndexedDBService","i2","NetworkService","i3","NotificationService","i4","HttpClient","factory","ɵfac","providedIn"],"sources":["C:\\Users\\leust\\source\\repos\\MPP-main\\Thrifto\\thrifto.client\\src\\app\\services\\offline-queue.service.ts"],"sourcesContent":["// src/app/services/offline-queue.service.ts\r\nimport { Injectable } from '@angular/core';\r\nimport { Observable, of, from, throwError } from 'rxjs';\r\nimport { catchError, switchMap, tap } from 'rxjs/operators';\r\nimport { IndexedDBService } from './indexed-db.service';\r\nimport { NetworkService, ConnectionStatus } from './network.service';\r\nimport { NotificationService } from './notification.service';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { environment } from '../../environments/environment';\r\n\r\nexport enum OperationType {\r\n  CREATE = 'CREATE',\r\n  UPDATE = 'UPDATE',\r\n  DELETE = 'DELETE'\r\n}\r\n\r\nexport interface PendingOperation {\r\n  id?: number;\r\n  entityType: string;\r\n  entityId?: number | string;\r\n  operationType: OperationType;\r\n  payload: any;\r\n  timestamp: number;\r\n  tempId?: number;\r\n  isOfflinePending?: boolean;\r\n}\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class OfflineQueueService {\r\n  private syncInProgress = false;\r\n  private apiUrl = environment.apiUrl;\r\n\r\n  constructor(\r\n    private indexedDBService: IndexedDBService,\r\n    private networkService: NetworkService,\r\n    private notificationService: NotificationService,\r\n    private http: HttpClient\r\n  ) {\r\n    // Listen for online status to trigger sync\r\n    this.networkService.status$.subscribe(status => {\r\n      if (status === ConnectionStatus.Online && !this.syncInProgress) {\r\n        this.syncPendingOperations();\r\n      }\r\n    });\r\n  }\r\n\r\n  // Queue a pending operation\r\n  queueOperation(operation: PendingOperation): Observable<PendingOperation> {\r\n    operation.timestamp = Date.now();\r\n    return this.indexedDBService.put<PendingOperation>('pendingOperations', operation);\r\n  }\r\n\r\n  // Get all pending operations\r\n  getPendingOperations(): Observable<PendingOperation[]> {\r\n    return this.indexedDBService.getAll<PendingOperation>('pendingOperations');\r\n  }\r\n\r\n  // Remove a pending operation\r\n  removePendingOperation(id: number): Observable<boolean> {\r\n    return this.indexedDBService.delete('pendingOperations', id);\r\n  }\r\n\r\n  // Sync all pending operations\r\n    syncPendingOperations(): void {\r\n        if (this.syncInProgress || !this.networkService.isOnline) {\r\n            return;\r\n        }\r\n\r\n        this.syncInProgress = true;\r\n\r\n        this.getPendingOperations().subscribe({\r\n            next: operations => {\r\n                // CHECK: If no operations, exit silently without showing notifications\r\n                if (operations.length === 0) {\r\n                    this.syncInProgress = false;\r\n                    return; // Exit early - no notifications needed\r\n                }\r\n\r\n                // Only show notifications if there are actual operations to sync\r\n                this.notificationService.show('Syncing offline changes...', 'info');\r\n\r\n                // Sort operations by timestamp (oldest first)\r\n                operations.sort((a, b) => a.timestamp - b.timestamp);\r\n\r\n                // Process each operation sequentially\r\n                this.processNextOperation(operations, 0);\r\n            },\r\n            error: error => {\r\n                console.error('Error getting pending operations:', error);\r\n                this.syncInProgress = false;\r\n                // Only show error notification if there was actually an error\r\n                // Don't show for empty queue\r\n            }\r\n        });\r\n    }\r\n\r\n    // Also update the processNextOperation method to only show success notification\r\n    // when operations were actually processed:\r\n    private processNextOperation(operations: PendingOperation[], index: number): void {\r\n        if (index >= operations.length) {\r\n            this.syncInProgress = false;\r\n\r\n            // Only show success notification if we actually processed operations\r\n            if (operations.length > 0) {\r\n                this.notificationService.show('All changes synced successfully!', 'success');\r\n            }\r\n            return;\r\n        }\r\n\r\n        const operation = operations[index];\r\n\r\n        // Execute the operation based on the service and operation type\r\n        this.executeOperation(operation).subscribe({\r\n            next: () => {\r\n                // Operation succeeded, remove from queue\r\n                this.removePendingOperation(operation.id!).subscribe(() => {\r\n                    // Process next operation\r\n                    this.processNextOperation(operations, index + 1);\r\n                });\r\n            },\r\n            error: error => {\r\n                console.error('Error syncing operation:', error);\r\n\r\n                // If server is down, stop syncing\r\n                if (!this.networkService.isOnline) {\r\n                    this.syncInProgress = false;\r\n                    this.notificationService.show('Network connection lost. Sync paused.', 'error');\r\n                    return;\r\n                }\r\n\r\n                // If it's a server error, we'll try again next time\r\n                // For now, let's continue with the next operation\r\n                this.processNextOperation(operations, index + 1);\r\n            }\r\n        });\r\n    }\r\n\r\n  private executeOperation(operation: PendingOperation): Observable<any> {\r\n    switch (operation.entityType) {\r\n      case 'listing':\r\n        return this.processListingOperation(operation);\r\n      case 'message':\r\n        return this.processMessageOperation(operation);\r\n      default:\r\n        return throwError(() => new Error(`Unknown entity type: ${operation.entityType}`));\r\n    }\r\n  }\r\n\r\n  private processListingOperation(operation: PendingOperation): Observable<any> {\r\n    const apiUrl = `${this.apiUrl}/listings`;\r\n\r\n    switch (operation.operationType) {\r\n      case OperationType.CREATE:\r\n        // For create operations, we need to convert the payload to FormData\r\n        const createFormData = this.convertToFormData(operation.payload);\r\n        return this.http.post(apiUrl, createFormData);\r\n\r\n      case OperationType.UPDATE:\r\n        // For update operations, we need to convert the payload to FormData\r\n        const updateFormData = this.convertToFormData(operation.payload);\r\n        return this.http.put(`${apiUrl}/${operation.entityId}`, updateFormData);\r\n\r\n      case OperationType.DELETE:\r\n        return this.http.delete(`${apiUrl}/${operation.entityId}`);\r\n\r\n      default:\r\n        return throwError(() => new Error(`Unknown operation type: ${operation.operationType}`));\r\n    }\r\n  }\r\n\r\n  private processMessageOperation(operation: PendingOperation): Observable<any> {\r\n    const apiUrl = `${this.apiUrl}/chat`;\r\n\r\n    switch (operation.operationType) {\r\n      case OperationType.CREATE:\r\n        return this.http.post(`${apiUrl}/messages`, operation.payload);\r\n\r\n      default:\r\n        return throwError(() => new Error(`Unknown operation type: ${operation.operationType}`));\r\n    }\r\n  }\r\n\r\n  private convertToFormData(payload: any): FormData {\r\n    const formData = new FormData();\r\n\r\n    // Add all primitive fields to formData\r\n    for (const key in payload) {\r\n      if (payload.hasOwnProperty(key) && payload[key] !== null && payload[key] !== undefined) {\r\n        // Skip file uploads and complex objects - these need special handling\r\n        if (typeof payload[key] !== 'object' || payload[key] instanceof File) {\r\n          formData.append(key, payload[key]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle photos array if present\r\n    if (payload.photos && Array.isArray(payload.photos)) {\r\n      payload.photos.forEach((photo: File, index: number) => {\r\n        if (photo instanceof File) {\r\n          formData.append(`Photos`, photo);\r\n        }\r\n      });\r\n    }\r\n\r\n    return formData;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}