{"ast":null,"code":"import { throwError } from 'rxjs';\nimport { skip } from 'rxjs/operators';\nimport { ConnectionStatus } from './network.service';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./indexed-db.service\";\nimport * as i2 from \"./network.service\";\nimport * as i3 from \"./notification.service\";\nimport * as i4 from \"@angular/common/http\";\nexport var OperationType;\n(function (OperationType) {\n  OperationType[\"CREATE\"] = \"CREATE\";\n  OperationType[\"UPDATE\"] = \"UPDATE\";\n  OperationType[\"DELETE\"] = \"DELETE\";\n})(OperationType || (OperationType = {}));\nexport class OfflineQueueService {\n  constructor(indexedDBService, networkService, notificationService, http) {\n    this.indexedDBService = indexedDBService;\n    this.networkService = networkService;\n    this.notificationService = notificationService;\n    this.http = http;\n    this.syncInProgress = false;\n    this.apiUrl = environment.apiUrl;\n    this.isInitialized = false; // ADD: Track initialization\n    // CHANGE: Skip the first emission (app initialization) and only react to actual network changes\n    this.networkService.status$.pipe(skip(1) // Skip the initial emission\n    ).subscribe(status => {\n      if (status === ConnectionStatus.Online && !this.syncInProgress && this.isInitialized) {\n        this.syncPendingOperations();\n      }\n    });\n    // CHANGE: Mark as initialized after a short delay to avoid initial sync\n    setTimeout(() => {\n      this.isInitialized = true;\n    }, 1000);\n  }\n  // Queue a pending operation\n  queueOperation(operation) {\n    operation.timestamp = Date.now();\n    this.isInitialized = true; // Mark as initialized when actual operations are added\n    return this.indexedDBService.put('pendingOperations', operation);\n  }\n  // Get all pending operations\n  getPendingOperations() {\n    return this.indexedDBService.getAll('pendingOperations');\n  }\n  // Remove a pending operation\n  removePendingOperation(id) {\n    return this.indexedDBService.delete('pendingOperations', id);\n  }\n  clearAllPendingOperations() {\n    return this.indexedDBService.clear('pendingOperations');\n  }\n  // Sync all pending operations\n  syncPendingOperations() {\n    if (this.syncInProgress || !this.networkService.isOnline || !this.isInitialized) {\n      return;\n    }\n    this.syncInProgress = true;\n    this.getPendingOperations().subscribe({\n      next: operations => {\n        // FIXED: Only show notifications if there are actual operations to sync\n        if (operations.length === 0) {\n          this.syncInProgress = false;\n          console.log('No pending operations to sync'); // Debug log instead of notification\n          return;\n        }\n        // Only show notifications if there are actual operations to sync\n        this.notificationService.show('Syncing offline changes...', 'info');\n        // Sort operations by timestamp (oldest first)\n        operations.sort((a, b) => a.timestamp - b.timestamp);\n        // Process each operation sequentially\n        this.processNextOperation(operations, 0);\n      },\n      error: error => {\n        console.error('Error getting pending operations:', error);\n        this.syncInProgress = false;\n      }\n    });\n  }\n  // CHANGE: Manual sync method for user-initiated syncs\n  forceSyncPendingOperations() {\n    this.isInitialized = true;\n    this.syncPendingOperations();\n  }\n  processNextOperation(operations, index) {\n    if (index >= operations.length) {\n      this.syncInProgress = false;\n      // Only show success notification if we actually processed operations\n      if (operations.length > 0) {\n        this.notificationService.show('All changes synced successfully!', 'success');\n      }\n      return;\n    }\n    const operation = operations[index];\n    // Execute the operation based on the service and operation type\n    this.executeOperation(operation).subscribe({\n      next: () => {\n        // Operation succeeded, remove from queue\n        this.removePendingOperation(operation.id).subscribe(() => {\n          // Process next operation\n          this.processNextOperation(operations, index + 1);\n        });\n      },\n      error: error => {\n        console.error('Error syncing operation:', error);\n        // If server is down, stop syncing\n        if (!this.networkService.isOnline) {\n          this.syncInProgress = false;\n          this.notificationService.show('Network connection lost. Sync paused.', 'error');\n          return;\n        }\n        // If it's a server error, we'll try again next time\n        // For now, let's continue with the next operation\n        this.processNextOperation(operations, index + 1);\n      }\n    });\n  }\n  executeOperation(operation) {\n    switch (operation.entityType) {\n      case 'listing':\n        return this.processListingOperation(operation);\n      case 'message':\n        return this.processMessageOperation(operation);\n      default:\n        return throwError(() => new Error(`Unknown entity type: ${operation.entityType}`));\n    }\n  }\n  processListingOperation(operation) {\n    const apiUrl = `${this.apiUrl}/listings`;\n    switch (operation.operationType) {\n      case OperationType.CREATE:\n        // For create operations, we need to convert the payload to FormData\n        const createFormData = this.convertToFormData(operation.payload);\n        return this.http.post(apiUrl, createFormData);\n      case OperationType.UPDATE:\n        // For update operations, we need to convert the payload to FormData\n        const updateFormData = this.convertToFormData(operation.payload);\n        return this.http.put(`${apiUrl}/${operation.entityId}`, updateFormData);\n      case OperationType.DELETE:\n        return this.http.delete(`${apiUrl}/${operation.entityId}`);\n      default:\n        return throwError(() => new Error(`Unknown operation type: ${operation.operationType}`));\n    }\n  }\n  processMessageOperation(operation) {\n    const apiUrl = `${this.apiUrl}/chat`;\n    switch (operation.operationType) {\n      case OperationType.CREATE:\n        return this.http.post(`${apiUrl}/messages`, operation.payload);\n      default:\n        return throwError(() => new Error(`Unknown operation type: ${operation.operationType}`));\n    }\n  }\n  convertToFormData(payload) {\n    const formData = new FormData();\n    // Add all primitive fields to formData\n    for (const key in payload) {\n      if (payload.hasOwnProperty(key) && payload[key] !== null && payload[key] !== undefined) {\n        // Skip file uploads and complex objects - these need special handling\n        if (typeof payload[key] !== 'object' || payload[key] instanceof File) {\n          formData.append(key, payload[key]);\n        }\n      }\n    }\n    // Handle photos array if present\n    if (payload.photos && Array.isArray(payload.photos)) {\n      payload.photos.forEach((photo, index) => {\n        if (photo instanceof File) {\n          formData.append(`Photos`, photo);\n        }\n      });\n    }\n    return formData;\n  }\n  static {\n    this.ɵfac = function OfflineQueueService_Factory(t) {\n      return new (t || OfflineQueueService)(i0.ɵɵinject(i1.IndexedDBService), i0.ɵɵinject(i2.NetworkService), i0.ɵɵinject(i3.NotificationService), i0.ɵɵinject(i4.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: OfflineQueueService,\n      factory: OfflineQueueService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["throwError","skip","ConnectionStatus","environment","OperationType","OfflineQueueService","constructor","indexedDBService","networkService","notificationService","http","syncInProgress","apiUrl","isInitialized","status$","pipe","subscribe","status","Online","syncPendingOperations","setTimeout","queueOperation","operation","timestamp","Date","now","put","getPendingOperations","getAll","removePendingOperation","id","delete","clearAllPendingOperations","clear","isOnline","next","operations","length","console","log","show","sort","a","b","processNextOperation","error","forceSyncPendingOperations","index","executeOperation","entityType","processListingOperation","processMessageOperation","Error","operationType","CREATE","createFormData","convertToFormData","payload","post","UPDATE","updateFormData","entityId","DELETE","formData","FormData","key","hasOwnProperty","undefined","File","append","photos","Array","isArray","forEach","photo","i0","ɵɵinject","i1","IndexedDBService","i2","NetworkService","i3","NotificationService","i4","HttpClient","factory","ɵfac","providedIn"],"sources":["C:\\Users\\leust\\source\\repos\\MPP-main\\Thrifto\\thrifto.client\\src\\app\\services\\offline-queue.service.ts"],"sourcesContent":["// src/app/services/offline-queue.service.ts\r\nimport { Injectable } from '@angular/core';\r\nimport { Observable, of, from, throwError } from 'rxjs';\r\nimport { catchError, switchMap, tap, skip } from 'rxjs/operators';\r\nimport { IndexedDBService } from './indexed-db.service';\r\nimport { NetworkService, ConnectionStatus } from './network.service';\r\nimport { NotificationService } from './notification.service';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { environment } from '../../environments/environment';\r\n\r\nexport enum OperationType {\r\n    CREATE = 'CREATE',\r\n    UPDATE = 'UPDATE',\r\n    DELETE = 'DELETE'\r\n}\r\n\r\nexport interface PendingOperation {\r\n    id?: number;\r\n    entityType: string;\r\n    entityId?: number | string;\r\n    operationType: OperationType;\r\n    payload: any;\r\n    timestamp: number;\r\n    tempId?: number;\r\n    isOfflinePending?: boolean;\r\n}\r\n\r\n@Injectable({\r\n    providedIn: 'root'\r\n})\r\nexport class OfflineQueueService {\r\n    private syncInProgress = false;\r\n    private apiUrl = environment.apiUrl;\r\n    private isInitialized = false; // ADD: Track initialization\r\n\r\n    constructor(\r\n        private indexedDBService: IndexedDBService,\r\n        private networkService: NetworkService,\r\n        private notificationService: NotificationService,\r\n        private http: HttpClient\r\n    ) {\r\n        // CHANGE: Skip the first emission (app initialization) and only react to actual network changes\r\n        this.networkService.status$.pipe(\r\n            skip(1) // Skip the initial emission\r\n        ).subscribe(status => {\r\n            if (status === ConnectionStatus.Online && !this.syncInProgress && this.isInitialized) {\r\n                this.syncPendingOperations();\r\n            }\r\n        });\r\n\r\n        // CHANGE: Mark as initialized after a short delay to avoid initial sync\r\n        setTimeout(() => {\r\n            this.isInitialized = true;\r\n        }, 1000);\r\n    }\r\n\r\n    // Queue a pending operation\r\n    queueOperation(operation: PendingOperation): Observable<PendingOperation> {\r\n        operation.timestamp = Date.now();\r\n        this.isInitialized = true; // Mark as initialized when actual operations are added\r\n        return this.indexedDBService.put<PendingOperation>('pendingOperations', operation);\r\n    }\r\n\r\n    // Get all pending operations\r\n    getPendingOperations(): Observable<PendingOperation[]> {\r\n        return this.indexedDBService.getAll<PendingOperation>('pendingOperations');\r\n    }\r\n\r\n    // Remove a pending operation\r\n    removePendingOperation(id: number): Observable<boolean> {\r\n        return this.indexedDBService.delete('pendingOperations', id);\r\n    }\r\n\r\n    public clearAllPendingOperations(): Observable<boolean> {\r\n        return this.indexedDBService.clear('pendingOperations');\r\n    }\r\n\r\n    // Sync all pending operations\r\n    syncPendingOperations(): void {\r\n        if (this.syncInProgress || !this.networkService.isOnline || !this.isInitialized) {\r\n            return;\r\n        }\r\n\r\n        this.syncInProgress = true;\r\n\r\n        this.getPendingOperations().subscribe({\r\n            next: operations => {\r\n                // FIXED: Only show notifications if there are actual operations to sync\r\n                if (operations.length === 0) {\r\n                    this.syncInProgress = false;\r\n                    console.log('No pending operations to sync'); // Debug log instead of notification\r\n                    return;\r\n                }\r\n\r\n                // Only show notifications if there are actual operations to sync\r\n                this.notificationService.show('Syncing offline changes...', 'info');\r\n\r\n                // Sort operations by timestamp (oldest first)\r\n                operations.sort((a, b) => a.timestamp - b.timestamp);\r\n\r\n                // Process each operation sequentially\r\n                this.processNextOperation(operations, 0);\r\n            },\r\n            error: error => {\r\n                console.error('Error getting pending operations:', error);\r\n                this.syncInProgress = false;\r\n            }\r\n        });\r\n    }\r\n\r\n    // CHANGE: Manual sync method for user-initiated syncs\r\n    public forceSyncPendingOperations(): void {\r\n        this.isInitialized = true;\r\n        this.syncPendingOperations();\r\n    }\r\n\r\n    private processNextOperation(operations: PendingOperation[], index: number): void {\r\n        if (index >= operations.length) {\r\n            this.syncInProgress = false;\r\n\r\n            // Only show success notification if we actually processed operations\r\n            if (operations.length > 0) {\r\n                this.notificationService.show('All changes synced successfully!', 'success');\r\n            }\r\n            return;\r\n        }\r\n\r\n        const operation = operations[index];\r\n\r\n        // Execute the operation based on the service and operation type\r\n        this.executeOperation(operation).subscribe({\r\n            next: () => {\r\n                // Operation succeeded, remove from queue\r\n                this.removePendingOperation(operation.id!).subscribe(() => {\r\n                    // Process next operation\r\n                    this.processNextOperation(operations, index + 1);\r\n                });\r\n            },\r\n            error: error => {\r\n                console.error('Error syncing operation:', error);\r\n\r\n                // If server is down, stop syncing\r\n                if (!this.networkService.isOnline) {\r\n                    this.syncInProgress = false;\r\n                    this.notificationService.show('Network connection lost. Sync paused.', 'error');\r\n                    return;\r\n                }\r\n\r\n                // If it's a server error, we'll try again next time\r\n                // For now, let's continue with the next operation\r\n                this.processNextOperation(operations, index + 1);\r\n            }\r\n        });\r\n    }\r\n\r\n    private executeOperation(operation: PendingOperation): Observable<any> {\r\n        switch (operation.entityType) {\r\n            case 'listing':\r\n                return this.processListingOperation(operation);\r\n            case 'message':\r\n                return this.processMessageOperation(operation);\r\n            default:\r\n                return throwError(() => new Error(`Unknown entity type: ${operation.entityType}`));\r\n        }\r\n    }\r\n\r\n    private processListingOperation(operation: PendingOperation): Observable<any> {\r\n        const apiUrl = `${this.apiUrl}/listings`;\r\n\r\n        switch (operation.operationType) {\r\n            case OperationType.CREATE:\r\n                // For create operations, we need to convert the payload to FormData\r\n                const createFormData = this.convertToFormData(operation.payload);\r\n                return this.http.post(apiUrl, createFormData);\r\n\r\n            case OperationType.UPDATE:\r\n                // For update operations, we need to convert the payload to FormData\r\n                const updateFormData = this.convertToFormData(operation.payload);\r\n                return this.http.put(`${apiUrl}/${operation.entityId}`, updateFormData);\r\n\r\n            case OperationType.DELETE:\r\n                return this.http.delete(`${apiUrl}/${operation.entityId}`);\r\n\r\n            default:\r\n                return throwError(() => new Error(`Unknown operation type: ${operation.operationType}`));\r\n        }\r\n    }\r\n\r\n    private processMessageOperation(operation: PendingOperation): Observable<any> {\r\n        const apiUrl = `${this.apiUrl}/chat`;\r\n\r\n        switch (operation.operationType) {\r\n            case OperationType.CREATE:\r\n                return this.http.post(`${apiUrl}/messages`, operation.payload);\r\n\r\n            default:\r\n                return throwError(() => new Error(`Unknown operation type: ${operation.operationType}`));\r\n        }\r\n    }\r\n\r\n    private convertToFormData(payload: any): FormData {\r\n        const formData = new FormData();\r\n\r\n        // Add all primitive fields to formData\r\n        for (const key in payload) {\r\n            if (payload.hasOwnProperty(key) && payload[key] !== null && payload[key] !== undefined) {\r\n                // Skip file uploads and complex objects - these need special handling\r\n                if (typeof payload[key] !== 'object' || payload[key] instanceof File) {\r\n                    formData.append(key, payload[key]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Handle photos array if present\r\n        if (payload.photos && Array.isArray(payload.photos)) {\r\n            payload.photos.forEach((photo: File, index: number) => {\r\n                if (photo instanceof File) {\r\n                    formData.append(`Photos`, photo);\r\n                }\r\n            });\r\n        }\r\n\r\n        return formData;\r\n    }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}