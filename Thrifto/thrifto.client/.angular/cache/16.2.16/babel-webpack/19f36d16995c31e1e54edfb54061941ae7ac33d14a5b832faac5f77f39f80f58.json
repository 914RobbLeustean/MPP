{"ast":null,"code":"import { from, throwError } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nexport class IndexedDBService {\n  constructor() {\n    this.dbName = 'thrifto-offline-db';\n    this.db = null;\n    this.dbVersion = 1;\n    this.initDB();\n  }\n  initDB() {\n    if (this.db) {\n      return Promise.resolve(this.db);\n    }\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.dbVersion);\n      request.onupgradeneeded = event => {\n        const db = event.target.result;\n        // Create object stores if they don't exist\n        if (!db.objectStoreNames.contains('listings')) {\n          const listingStore = db.createObjectStore('listings', {\n            keyPath: 'id'\n          });\n          listingStore.createIndex('userId', 'userId', {\n            unique: false\n          });\n          listingStore.createIndex('quality', 'quality', {\n            unique: false\n          });\n        }\n        if (!db.objectStoreNames.contains('pendingOperations')) {\n          const pendingStore = db.createObjectStore('pendingOperations', {\n            keyPath: 'id',\n            autoIncrement: true\n          });\n          pendingStore.createIndex('entityType', 'entityType', {\n            unique: false\n          });\n          pendingStore.createIndex('operationType', 'operationType', {\n            unique: false\n          });\n        }\n        if (!db.objectStoreNames.contains('messages')) {\n          const messagesStore = db.createObjectStore('messages', {\n            keyPath: 'id'\n          });\n          messagesStore.createIndex('senderId', 'senderId', {\n            unique: false\n          });\n        }\n        if (!db.objectStoreNames.contains('conversations')) {\n          const conversationsStore = db.createObjectStore('conversations', {\n            keyPath: 'userId'\n          });\n        }\n        if (!db.objectStoreNames.contains('user')) {\n          db.createObjectStore('user', {\n            keyPath: 'id'\n          });\n        }\n      };\n      request.onsuccess = event => {\n        this.db = event.target.result;\n        resolve(this.db);\n      };\n      request.onerror = event => {\n        reject('Error opening IndexedDB: ' + event.target.error);\n      };\n    });\n  }\n  // Get data from a store by key\n  get(storeName, key) {\n    return from(this.initDB().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction(storeName, 'readonly');\n        const store = transaction.objectStore(storeName);\n        const request = store.get(key);\n        request.onsuccess = () => {\n          resolve(request.result);\n        };\n        request.onerror = () => {\n          reject(request.error);\n        };\n      });\n    })).pipe(catchError(error => throwError(() => `Error getting data from IndexedDB: ${error}`)));\n  }\n  // Get all data from a store\n  getAll(storeName) {\n    return from(this.initDB().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction(storeName, 'readonly');\n        const store = transaction.objectStore(storeName);\n        const request = store.getAll();\n        request.onsuccess = () => {\n          resolve(request.result);\n        };\n        request.onerror = () => {\n          reject(request.error);\n        };\n      });\n    })).pipe(catchError(error => throwError(() => `Error getting all data from IndexedDB: ${error}`)));\n  }\n  // Get data by index\n  getByIndex(storeName, indexName, value) {\n    return from(this.initDB().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction(storeName, 'readonly');\n        const store = transaction.objectStore(storeName);\n        const index = store.index(indexName);\n        const request = index.getAll(value);\n        request.onsuccess = () => {\n          resolve(request.result);\n        };\n        request.onerror = () => {\n          reject(request.error);\n        };\n      });\n    })).pipe(catchError(error => throwError(() => `Error getting data by index from IndexedDB: ${error}`)));\n  }\n  // Add or update data in a store\n  put(storeName, item) {\n    return from(this.initDB().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction(storeName, 'readwrite');\n        const store = transaction.objectStore(storeName);\n        const request = store.put(item);\n        request.onsuccess = () => {\n          resolve(item);\n        };\n        request.onerror = () => {\n          reject(request.error);\n        };\n      });\n    })).pipe(catchError(error => throwError(() => `Error putting data in IndexedDB: ${error}`)));\n  }\n  // Delete data from a store\n  delete(storeName, key) {\n    return from(this.initDB().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction(storeName, 'readwrite');\n        const store = transaction.objectStore(storeName);\n        const request = store.delete(key);\n        request.onsuccess = () => {\n          resolve(true);\n        };\n        request.onerror = () => {\n          reject(request.error);\n        };\n      });\n    })).pipe(catchError(error => throwError(() => `Error deleting data from IndexedDB: ${error}`)));\n  }\n  // Clear a store\n  clear(storeName) {\n    return from(this.initDB().then(db => {\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction(storeName, 'readwrite');\n        const store = transaction.objectStore(storeName);\n        const request = store.clear();\n        request.onsuccess = () => {\n          resolve(true);\n        };\n        request.onerror = () => {\n          reject(request.error);\n        };\n      });\n    })).pipe(catchError(error => throwError(() => `Error clearing store in IndexedDB: ${error}`)));\n  }\n  static {\n    this.ɵfac = function IndexedDBService_Factory(t) {\n      return new (t || IndexedDBService)();\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: IndexedDBService,\n      factory: IndexedDBService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["from","throwError","catchError","IndexedDBService","constructor","dbName","db","dbVersion","initDB","Promise","resolve","reject","request","indexedDB","open","onupgradeneeded","event","target","result","objectStoreNames","contains","listingStore","createObjectStore","keyPath","createIndex","unique","pendingStore","autoIncrement","messagesStore","conversationsStore","onsuccess","onerror","error","get","storeName","key","then","transaction","store","objectStore","pipe","getAll","getByIndex","indexName","value","index","put","item","delete","clear","factory","ɵfac","providedIn"],"sources":["C:\\Users\\leust\\source\\repos\\MPP-main\\Thrifto\\thrifto.client\\src\\app\\services\\indexed-db.service.ts"],"sourcesContent":["// src/app/services/indexed-db.service.ts\r\nimport { Injectable } from '@angular/core';\r\nimport { Observable, from, throwError } from 'rxjs';\r\nimport { map, catchError } from 'rxjs/operators';\r\nimport { Listing } from '../models/listing.model';\r\nimport { ChatMessage, Conversation } from '../models/chat-message.model';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class IndexedDBService {\r\n  private dbName = 'thrifto-offline-db';\r\n  private db: IDBDatabase | null = null;\r\n  private dbVersion = 1;\r\n\r\n  constructor() {\r\n    this.initDB();\r\n  }\r\n\r\n  private initDB(): Promise<IDBDatabase> {\r\n    if (this.db) {\r\n      return Promise.resolve(this.db);\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = indexedDB.open(this.dbName, this.dbVersion);\r\n\r\n      request.onupgradeneeded = (event) => {\r\n        const db = (event.target as IDBOpenDBRequest).result;\r\n\r\n        // Create object stores if they don't exist\r\n        if (!db.objectStoreNames.contains('listings')) {\r\n          const listingStore = db.createObjectStore('listings', { keyPath: 'id' });\r\n          listingStore.createIndex('userId', 'userId', { unique: false });\r\n          listingStore.createIndex('quality', 'quality', { unique: false });\r\n        }\r\n\r\n        if (!db.objectStoreNames.contains('pendingOperations')) {\r\n          const pendingStore = db.createObjectStore('pendingOperations', { keyPath: 'id', autoIncrement: true });\r\n          pendingStore.createIndex('entityType', 'entityType', { unique: false });\r\n          pendingStore.createIndex('operationType', 'operationType', { unique: false });\r\n        }\r\n\r\n        if (!db.objectStoreNames.contains('messages')) {\r\n          const messagesStore = db.createObjectStore('messages', { keyPath: 'id' });\r\n          messagesStore.createIndex('senderId', 'senderId', { unique: false });\r\n        }\r\n\r\n        if (!db.objectStoreNames.contains('conversations')) {\r\n          const conversationsStore = db.createObjectStore('conversations', { keyPath: 'userId' });\r\n        }\r\n\r\n        if (!db.objectStoreNames.contains('user')) {\r\n          db.createObjectStore('user', { keyPath: 'id' });\r\n        }\r\n      };\r\n\r\n      request.onsuccess = (event) => {\r\n        this.db = (event.target as IDBOpenDBRequest).result;\r\n        resolve(this.db);\r\n      };\r\n\r\n      request.onerror = (event) => {\r\n        reject('Error opening IndexedDB: ' + (event.target as IDBOpenDBRequest).error);\r\n      };\r\n    });\r\n  }\r\n\r\n  // Get data from a store by key\r\n  get<T>(storeName: string, key: any): Observable<T> {\r\n    return from(this.initDB()\r\n      .then(db => {\r\n        return new Promise<T>((resolve, reject) => {\r\n          const transaction = db.transaction(storeName, 'readonly');\r\n          const store = transaction.objectStore(storeName);\r\n          const request = store.get(key);\r\n\r\n          request.onsuccess = () => {\r\n            resolve(request.result);\r\n          };\r\n\r\n          request.onerror = () => {\r\n            reject(request.error);\r\n          };\r\n        });\r\n      }))\r\n      .pipe(\r\n        catchError(error => throwError(() => `Error getting data from IndexedDB: ${error}`))\r\n      );\r\n  }\r\n\r\n  // Get all data from a store\r\n  getAll<T>(storeName: string): Observable<T[]> {\r\n    return from(this.initDB()\r\n      .then(db => {\r\n        return new Promise<T[]>((resolve, reject) => {\r\n          const transaction = db.transaction(storeName, 'readonly');\r\n          const store = transaction.objectStore(storeName);\r\n          const request = store.getAll();\r\n\r\n          request.onsuccess = () => {\r\n            resolve(request.result);\r\n          };\r\n\r\n          request.onerror = () => {\r\n            reject(request.error);\r\n          };\r\n        });\r\n      }))\r\n      .pipe(\r\n        catchError(error => throwError(() => `Error getting all data from IndexedDB: ${error}`))\r\n      );\r\n  }\r\n\r\n  // Get data by index\r\n  getByIndex<T>(storeName: string, indexName: string, value: any): Observable<T[]> {\r\n    return from(this.initDB()\r\n      .then(db => {\r\n        return new Promise<T[]>((resolve, reject) => {\r\n          const transaction = db.transaction(storeName, 'readonly');\r\n          const store = transaction.objectStore(storeName);\r\n          const index = store.index(indexName);\r\n          const request = index.getAll(value);\r\n\r\n          request.onsuccess = () => {\r\n            resolve(request.result);\r\n          };\r\n\r\n          request.onerror = () => {\r\n            reject(request.error);\r\n          };\r\n        });\r\n      }))\r\n      .pipe(\r\n        catchError(error => throwError(() => `Error getting data by index from IndexedDB: ${error}`))\r\n      );\r\n  }\r\n\r\n  // Add or update data in a store\r\n  put<T>(storeName: string, item: T): Observable<T> {\r\n    return from(this.initDB()\r\n      .then(db => {\r\n        return new Promise<T>((resolve, reject) => {\r\n          const transaction = db.transaction(storeName, 'readwrite');\r\n          const store = transaction.objectStore(storeName);\r\n          const request = store.put(item);\r\n\r\n          request.onsuccess = () => {\r\n            resolve(item);\r\n          };\r\n\r\n          request.onerror = () => {\r\n            reject(request.error);\r\n          };\r\n        });\r\n      }))\r\n      .pipe(\r\n        catchError(error => throwError(() => `Error putting data in IndexedDB: ${error}`))\r\n      );\r\n  }\r\n\r\n  // Delete data from a store\r\n  delete(storeName: string, key: any): Observable<boolean> {\r\n    return from(this.initDB()\r\n      .then(db => {\r\n        return new Promise<boolean>((resolve, reject) => {\r\n          const transaction = db.transaction(storeName, 'readwrite');\r\n          const store = transaction.objectStore(storeName);\r\n          const request = store.delete(key);\r\n\r\n          request.onsuccess = () => {\r\n            resolve(true);\r\n          };\r\n\r\n          request.onerror = () => {\r\n            reject(request.error);\r\n          };\r\n        });\r\n      }))\r\n      .pipe(\r\n        catchError(error => throwError(() => `Error deleting data from IndexedDB: ${error}`))\r\n      );\r\n  }\r\n\r\n  // Clear a store\r\n  clear(storeName: string): Observable<boolean> {\r\n    return from(this.initDB()\r\n      .then(db => {\r\n        return new Promise<boolean>((resolve, reject) => {\r\n          const transaction = db.transaction(storeName, 'readwrite');\r\n          const store = transaction.objectStore(storeName);\r\n          const request = store.clear();\r\n\r\n          request.onsuccess = () => {\r\n            resolve(true);\r\n          };\r\n\r\n          request.onerror = () => {\r\n            reject(request.error);\r\n          };\r\n        });\r\n      }))\r\n      .pipe(\r\n        catchError(error => throwError(() => `Error clearing store in IndexedDB: ${error}`))\r\n      );\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}